info={ver='1.22.2',author='hds536jhmk',website='https://github.com/hds536jhmk/APLib'}globalMonitor=term;globalMonitorName='term'globalMonitorGroup={enabled=false,list={}}globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()globalMonitorBuffer={enabled=false,pixels={lastFrame={},newFrame={}},clear=function()globalMonitorBuffer.pixels.newFrame={}end,write=function(a,b,text,c,d,e)assert(type(a)=='number','globalMonitorBuffer.write: x must be a number, got '..type(a))assert(type(b)=='number','globalMonitorBuffer.write: y must be a number, got '..type(b))assert(type(c)=='number','globalMonitorBuffer.write: fg must be a number, got '..type(c))assert(type(d)=='number'or e,'globalMonitorBuffer.write: bg must be a number, got '..type(d))b=tostring(b)if not globalMonitorBuffer.pixels.newFrame[b]then globalMonitorBuffer.pixels.newFrame[b]={}end;text=tostring(text)for f in text:gmatch('.')do local g=globalMonitorBuffer.pixels.newFrame[b][tostring(a)]local h=d;if e then if g then h=g.bg else h=globalMonitor.getBackgroundColor()end end;globalMonitorBuffer.pixels.newFrame[b][tostring(a)]={char=f,fg=c,bg=h}a=a+1 end end,draw=function()local i,j=globalMonitor.getCursorPos()local k=globalMonitor.getTextColor()local l=globalMonitor.getBackgroundColor()for b=1,globalMonitorHeight do local m=globalMonitorBuffer.pixels.newFrame[tostring(b)]for a=1,globalMonitorWidth do globalMonitor.setCursorPos(a,b)if m then local g=m[tostring(a)]if g then globalMonitor.setTextColor(g.fg)globalMonitor.setBackgroundColor(g.bg)globalMonitor.write(g.char)else globalMonitor.setBackgroundColor(l)globalMonitor.write(' ')end else globalMonitor.setBackgroundColor(l)globalMonitor.write(string.rep(' ',globalMonitorWidth))break end end end;globalMonitor.setCursorPos(i,j)globalMonitor.setTextColor(k)globalMonitor.setBackgroundColor(l)globalMonitorBuffer.pixels.lastFrame=globalMonitorBuffer.pixels.newFrame end}function setRenderer(n)assert(type(n)=='number','setRenderer: type must be a number, got '..type(n))if n==1 then globalMonitorBuffer.enabled=false elseif n==2 then globalMonitorBuffer.enabled=true end end;globalColor=colors.white;globalTextColor=colors.white;globalBackgroundTextColor=colors.black;globalRectangleType=1;globalLoop={enabled=false,autoClear=true,drawOnClock=true,clockSpeed=0.5,timerSpeed=0.1,clock=0,APLWDBroadcastOnClock=false,APLWDClearCacheOnDraw=true,stats={automaticPos=true,automaticPosOffset={x=0,y=0}},callbacks={onInit=function()end,onStop=function()end,onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end},events={draw={},touch={},tick={},key={},char={},mouse_drag={}},wasGroupChanged=false,selectedGroup='none',group={none={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}},LIBPrivate={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}}}}globalCallbacks={onBClear=function()end,onSetMonitor=function()end}renderEngine={classic=1,experimental=2}rectangleTypes={filled=1,hollow=2,checker=3}event={global={onBClear=1,onSetMonitor=2},clock={onClock=1},point={onDraw=1,onPress=2,onFailedPress=3},rectangle={onDraw=1,onPress=2,onFailedPress=3},header={onDraw=1,onPress=2,onFailedPress=3},label={onDraw=1,onPress=2,onFailedPress=3},button={onDraw=1,onPress=2,onFailedPress=3},menu={onDraw=1,onPress=2,onFailedPress=3,onButtonPress=4,onFailedButtonPress=5},percentagebar={onDraw=1,onPress=2,onFailedPress=3},memo={onDraw=1,onPress=2,onFailedPress=3,onEdit=4,onCursorBlink=5,onActivated=6,onDeactivated=7},window={onDraw=1,onPress=2,onFailedPress=3,onOBJPress=4,onFailedOBJPress=5,onEvent=6},objGroup={onDraw=1,onOBJPress=2,onFailedOBJPress=3},loop={group={onClock=1,onEvent=2,onTimer=3,onMonitorChange=4,onSet=5,onUnset=6},onInit=1,onStop=2,onClock=3,onEvent=4,onTimer=5,onMonitorChange=6}}function stringSplit(o,p)o=tostring(o)p=tostring(p)local q={}while true do local r=o:find(p)if r then table.insert(q,o:sub(1,r-1))o=o:sub(r+1)else table.insert(q,o)break end end;return q end;function tableHasKey(s,t)assert(type(s)=='table','tableHasKey: table must be a table, got '..type(s))assert(type(t)=='string'or type(t)=='number','tableHasKey: key must be a string or a number, got '..type(t))for u,v in pairs(s)do if u==t then return true,v end end;return false end;function tableHasValue(s,w)assert(type(s)=='table','tableHasValue: table must be a table, got '..type(s))for u,v in pairs(s)do if v==w then return true,u end end;return false end;OSSettings={settingsPath='/.settings',set=function(x,w)assert(type(w)~='nil',"OSSettings.set: value can't be nil, got "..type(w))settings.set(tostring(x),w)return settings.save(OSSettings.settingsPath)end,get=function(x)return settings.get(tostring(x))end,getNames=function()return settings.getNames()end,unset=function(x)settings.unset(tostring(x))return settings.save(OSSettings.settingsPath)end}function setGlobalCallback(y,z)assert(type(z)=='function','setGlobalCallback: callback must be a function, got '..type(z))if y==1 then globalCallbacks.onBClear=z elseif y==2 then globalCallbacks.onSetMonitor=z end end;function bClear()if globalMonitorBuffer.enabled then globalMonitorBuffer.clear()else globalMonitor.clear()globalMonitor.setCursorPos(1,1)end;globalCallbacks.onBClear()if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='bClear'})end end;function bClearMonitorGroup()if globalMonitorGroup.enabled then globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)bClear()local A=APLWD.cacheWritable;if APLWD.enabled and A then APLWD.cacheWritable=false end;local B=globalMonitorName;for C,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=B then setMonitor(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)bClear()end end;setMonitor(B)if APLWD.enabled and A then APLWD.cacheWritable=true end else bClear()end end;function setMonitor(D)D=tostring(D)globalCallbacks.onSetMonitor(globalMonitor,globalMonitorName,globalMonitorWidth,globalMonitorHeight)if D=='term'then globalMonitor=term;globalMonitorName='term'globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()else assert(tostring(peripheral.getType(D))=='monitor','setMonitor: monitorName must be a monitor, got '..tostring(peripheral.getType(D)))local E=peripheral.wrap(D)globalMonitor=E;globalMonitorName=D;globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()end end;function getMonitorSize()return globalMonitorWidth,globalMonitorHeight end;function setMonitorGroup(F)assert(type(F)=='table','setMonitorGroup: monitorNameList must be a table, got '..type(F))for u,v in pairs(F)do v=tostring(v)if not v=='term'then assert(tostring(peripheral.getType(v))=='monitor','setMonitorGroup: '..v..' must be a monitor, got '..tostring(peripheral.getType(v)))end end;globalMonitorGroup.list=F end;function setMonitorGroupEnabled(G)assert(type(G)=='boolean','setMonitorGroupEnabled: bool must be a boolean, got '..type(G))globalMonitorGroup.enabled=G end;function resetMonitorGroup()globalMonitorGroup.list={}end;APLWD={enabled=false,cacheWritable=true,clearOnDraw=false,protocol='APLWD-'..info.ver,senderName='SendeR',receiverName='ReceiveR',isReceiver=true,myName='',senderID='',modemName='',cache={}}APLWD.enable=function(G)assert(type(G)=='boolean','APLWD.enable: bool must be a boolean, got '..type(G))APLWD.enabled=G end;APLWD.broadcastOnLoopClock=function()globalLoop.APLWDBroadcastOnClock=true end;APLWD.dontBroadcastOnLoopClock=function()globalLoop.APLWDBroadcastOnClock=false end;APLWD.enableClearCacheOnLoopDraw=function(G)assert(type(G)=='boolean','APLWD.enableClearCacheOnLoopDraw: bool must be a boolean, got '..type(G))globalLoop.APLWDClearCacheOnDraw=G end;APLWD.host=function(H,I)if APLWD.enabled then H=tostring(H)if I then I=tostring(I)else I=tostring(os.getComputerID())end;assert(tostring(peripheral.getType(H))=='modem','APLWD.host: modemName must be a modem, got '..tostring(peripheral.getType(H)))rednet.open(H)if rednet.lookup(APLWD.protocol,APLWD.senderName..I)then rednet.close(H)error("APLWD.host: There's already someone connected with hostname: "..I)end;rednet.host(APLWD.protocol,APLWD.senderName..I)APLWD.isReceiver=false;APLWD.myName=APLWD.senderName..I;APLWD.modemName=H end end;APLWD.connect=function(H,J,I)if APLWD.enabled then H=tostring(H)if I then I=tostring(I)else I=tostring(os.getComputerID())end;J=tostring(J)assert(tostring(peripheral.getType(H))=='modem','APLWD.connect: modemName must be a modem, got '..tostring(peripheral.getType(H)))rednet.open(H)if rednet.lookup(APLWD.protocol,APLWD.receiverName..I)then rednet.close(H)error("APLWD.connect: There's already someone connected with hostname: "..I)end;local K=rednet.lookup(APLWD.protocol,APLWD.senderName..J)if not K then rednet.close(H)error("APLWD.connect: Didn't find any sender with name: "..J)end;rednet.host(APLWD.protocol,APLWD.receiverName..I)APLWD.isReceiver=true;APLWD.myName=APLWD.receiverName..I;APLWD.senderID=K;APLWD.modemName=H end end;APLWD.close=function()if APLWD.modemName~=''then if not APLWD.isReceiver then rednet.broadcast('disconnected',APLWD.protocol)end;rednet.unhost(APLWD.protocol,APLWD.myName)rednet.close(APLWD.modemName)APLWD.enable(false)APLWD.clearCache()APLWD.isReceiver=true;APLWD.myName=''APLWD.senderID=''APLWD.modemName=''end end;APLWD.broadcastCache=function()if APLWD.enabled then local L=rednet.isOpen()assert(L,'APLWD.broadcastCache: rednet connection must be opened first, connection '..tostring(L))rednet.broadcast(APLWD.cache,APLWD.protocol)APLWD.clearCache()end end;APLWD.receiveCache=function(M)if APLWD.enabled then local L=rednet.isOpen()assert(L,'APLWD.receiveCache: rednet connection must be opened first, connection '..tostring(L))local K,N,O=rednet.receive(APLWD.protocol,tonumber(M))if type(N)=='table'then if K==APLWD.senderID then APLWD.cache=N;return true end elseif N=='disconnected'then APLWD.close()return false,'disconnected'end;return false end end;APLWD.drawCache=function()if APLWD.enabled then local function P()for u,v in pairs(APLWD.cache)do if v.type=='bClear'then bClearMonitorGroup()elseif v.type=='background'then setBackgroundMonitorGroup(v.color)elseif v.type=='text'then local k=globalTextColor;local Q=globalBackgroundTextColor;setTextColor(v.colors.textColor)setBackgroundTextColor(v.colors.backgroundTextColor)text(v.pos.x,v.pos.y,v.text,v.colors.transparentBG)setTextColor(k)setBackgroundTextColor(Q)elseif v.type=='point'then local R=globalColor;setColor(v.color)point(v.pos.x,v.pos.y)setColor(R)elseif v.type=='rectangle'then local R=globalColor;setColor(v.color)rectangle(v.pos.x1,v.pos.y1,v.pos.x2,v.pos.y2)setColor(R)end end end;if globalMonitorGroup.enabled then if APLWD.clearOnDraw then bClear()end;P()if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()end;local B=globalMonitorName;for C,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=B then setMonitor(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()else P()end end end;setMonitor(B)else if APLWD.clearOnDraw then bClear()end;P()if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()end end;APLWD.clearCache()end end;APLWD.clearCache=function()APLWD.cache={}end;function setColor(S)assert(type(S)=='number','setColor: color must be a number, got '..type(S))globalColor=S end;function setTextColor(S)assert(type(S)=='number','setTextColor: color must be a number, got '..type(S))globalTextColor=S end;function setBackgroundTextColor(S)assert(type(S)=='number','setBackgroundTextColor: color must be a number, got '..type(S))globalBackgroundTextColor=S end;function setBackground(S)assert(type(S)=='number','setBackgroundColor: color must be a number, got '..type(S))if globalMonitorBuffer.enabled then globalMonitor.setBackgroundColor(S)else globalMonitor.setBackgroundColor(S)local A=APLWD.cacheWritable;if APLWD.enabled and A then APLWD.cacheWritable=false end;bClear()if APLWD.enabled and A then APLWD.cacheWritable=true end end;if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='background',color=S})end end;function setBackgroundMonitorGroup(S)assert(type(S)=='number','setBackgroundMonitorGroup: color must be a number, got '..type(S))if globalMonitorGroup.enabled then globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)setBackground(S)local A=APLWD.cacheWritable;if APLWD.enabled and A then APLWD.cacheWritable=false end;local B=globalMonitorName;for C,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=B then setMonitor(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)setBackground(S)end end;setMonitor(B)if APLWD.enabled and A then APLWD.cacheWritable=true end else setBackground(S)end end;function setRectangleType(n)assert(type(n)=='number','setRectangleType: type must be a number, got '..type(n))globalRectangleType=n end;function text(T,U,V,W)assert(type(T)=='number','Text: x must be a number, got '..type(T))assert(type(U)=='number','Text: y must be a number, got '..type(U))V=tostring(V)local i,j=globalMonitor.getCursorPos()local k=globalMonitor.getTextColor()local l=globalMonitor.getBackgroundColor()globalMonitor.setTextColor(globalTextColor)globalMonitor.setBackgroundColor(globalBackgroundTextColor)local X=stringSplit(V,'\n')for u,v in pairs(X)do if globalMonitorBuffer.enabled then globalMonitorBuffer.write(T,U+u-1,v,globalTextColor,globalBackgroundTextColor,W)else globalMonitor.setCursorPos(T,U+u-1)globalMonitor.write(v)end end;globalMonitor.setCursorPos(i,j)globalMonitor.setTextColor(k)globalMonitor.setBackgroundColor(l)if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='text',text=V,pos={x=T,y=U},colors={textColor=globalTextColor,backgroundTextColor=globalBackgroundTextColor,transparentBG=W}})end end;function point(T,U)assert(type(T)=='number','Point: x must be a number, got '..type(T))assert(type(U)=='number','Point: y must be a number, got '..type(U))local i,j=globalMonitor.getCursorPos()local l=globalMonitor.getBackgroundColor()globalMonitor.setBackgroundColor(globalColor)if globalMonitorBuffer.enabled then globalMonitorBuffer.write(T,U,' ',globalColor,globalColor)else globalMonitor.setCursorPos(T,U)globalMonitor.write(' ')end;globalMonitor.setCursorPos(i,j)globalMonitor.setBackgroundColor(l)if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='point',pos={x=T,y=U},color=globalColor})end end;function rectangle(Y,Z,_,a0)assert(type(Y)=='number','Point: x1 must be a number, got '..type(Y))assert(type(Z)=='number','Point: y1 must be a number, got '..type(Z))assert(type(_)=='number','Point: x2 must be a number, got '..type(_))assert(type(a0)=='number','Point: y2 must be a number, got '..type(a0))local a1=1;local a2=1;if Y>_ then a1=-1 end;if Z>a0 then a2=-1 end;local A=APLWD.cacheWritable;if APLWD.enabled and A then APLWD.cacheWritable=false end;if globalRectangleType==1 then for a=Y,_,a1 do for b=Z,a0,a2 do point(a,b)end end elseif globalRectangleType==2 then for a=Y,_,a1 do point(a,Z)point(a,a0)end;for b=Z,a0,a2 do point(Y,b)point(_,b)end elseif globalRectangleType==3 then local a3=true;for a=Y,_,a1 do for b=Z,a0,a2 do if a3 then point(a,b)end;a3=not a3 end;if math.abs(Y-_)%2~=0 then a3=not a3 end end end;if APLWD.enabled and A then APLWD.cacheWritable=true end;if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='rectangle',pos={x1=Y,y1=Z,x2=_,y2=a0},color=globalColor})end end;function checkAreaPress(Y,Z,_,a0,a4,a5)assert(type(Y)=='number','checkAreaPress: x1 must be a number, got '..type(Y))assert(type(Z)=='number','checkAreaPress: y1 must be a number, got '..type(Z))assert(type(_)=='number','checkAreaPress: x2 must be a number, got '..type(_))assert(type(a0)=='number','checkAreaPress: y2 must be a number, got '..type(a0))assert(type(a4)=='number','checkAreaPress: xPressed must be a number, got '..type(a4))assert(type(a5)=='number','checkAreaPress: yPressed must be a number, got '..type(a5))if Y<_ then if not(a4>=Y and a4<=_)then return false end else if not(a4<=Y and a4>=_)then return false end end;if Z<a0 then if not(a5>=Z and a5<=a0)then return false end else if not(a5<=Z and a5>=a0)then return false end end;return true end;Clock={}function Clock.new(a6)assert(type(a6)=='number','Clock.new: interval must be a number, got '..type(a6))_newClock={clock=os.clock(),interval=a6,callbacks={onClock=function()end}}setmetatable(_newClock,Clock)return _newClock end;function Clock:setCallback(y,z)assert(type(z)=='function','Clock.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onClock=z end end;function Clock:tick(y)if os.clock()>=self.clock+self.interval then self.clock=os.clock()self.callbacks.onClock(self,y)return true end;return false end;Clock.__index=Clock;Point={}function Point.new(T,U,S)assert(type(T)=='number','Point.new: x must be a number, got '..type(T))assert(type(U)=='number','Point.new: y must be a number, got '..type(U))S=tonumber(S)if not S then S=globalColor end;_newPoint={color=S,hidden=false,pos={x=T,y=U},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newPoint,Point)return _newPoint end;function Point:draw()if not self.hidden then self.callbacks.onDraw(self)local R=globalColor;setColor(self.color)point(self.pos.x,self.pos.y)setColor(R)end end;function Point:setCallback(y,z)assert(type(z)=='function','Point.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z end end;function Point:touch(T,U,y,a7)assert(type(T)=='number','Point.touch: x must be a number, got '..type(T))assert(type(U)=='number','Point.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then if self.pos.x==T and self.pos.y==U then self.callbacks.onPress(self,y)return true else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function Point:hide(G)assert(type(G)=='boolean','Point.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Point.__index=Point;Rectangle={}function Rectangle.new(Y,Z,_,a0,S,n)assert(type(Y)=='number','Rectangle.new: x1 must be a number, got '..type(Y))assert(type(Z)=='number','Rectangle.new: y1 must be a number, got '..type(Z))assert(type(_)=='number','Rectangle.new: x2 must be a number, got '..type(_))assert(type(a0)=='number','Rectangle.new: y2 must be a number, got '..type(a0))S=tonumber(S)n=tonumber(n)if not S then S=globalColor end;if not n then n=globalRectangleType end;_newRectangle={color=S,type=n,hidden=false,pos={x1=Y,y1=Z,x2=_,y2=a0},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newRectangle,Rectangle)return _newRectangle end;function Rectangle:draw()if not self.hidden then self.callbacks.onDraw(self)local a8=globalRectangleType;local R=globalColor;setRectangleType(self.type)setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)setRectangleType(a8)setColor(R)end end;function Rectangle:setCallback(y,z)assert(type(z)=='function','Rectangle.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z end end;function Rectangle:touch(T,U,y,a7)assert(type(T)=='number','Rectangle.touch: x must be a number, got '..type(T))assert(type(U)=='number','Rectangle.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,T,U)then self.callbacks.onPress(self,y)return true else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function Rectangle:hide(G)assert(type(G)=='boolean','Rectangle.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Rectangle.__index=Rectangle;Header={}function Header.new(U,V,a9,aa,W)assert(type(U)=='number','Header.new: y must be a number, got '..type(U))V=tostring(V)a9=tonumber(a9)aa=tonumber(aa)if not a9 then a9=globalTextColor end;_newHeader={text=V,hidden=false,pos={x=math.floor((globalMonitorWidth-string.len(V)+1)/2),y=U},colors={textColor=a9,backgroundTextColor=aa,transparentBG=W},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newHeader,Header)return _newHeader end;function Header:draw()if not self.hidden then self.callbacks.onDraw(self)local k=globalTextColor;local Q=globalBackgroundTextColor;local ab=globalMonitor.getBackgroundColor()setTextColor(self.colors.textColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(ab)end;local X=stringSplit(self.text,'\n')self.pos.x=math.floor((globalMonitorWidth-string.len(X[1])+1)/2)text(self.pos.x,self.pos.y,X[1],self.colors.transparentBG)table.remove(X,1)for u,v in pairs(X)do local ac=math.floor((globalMonitorWidth-string.len(v)+1)/2)local ad=self.pos.y+u;text(ac,ad,v)end;setTextColor(k)setBackgroundTextColor(Q)end end;function Header:setCallback(y,z)assert(type(z)=='function','Header.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z end end;function Header:touch(T,U,y,a7)assert(type(T)=='number','Header.touch: x must be a number, got '..type(T))assert(type(U)=='number','Header.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then self.pos.x=math.floor((globalMonitorWidth-string.len(self.text)+1)/2)local _=self.pos.x+string.len(self.text)-1;if checkAreaPress(self.pos.x,self.pos.y,_,self.pos.y,T,U)then self.callbacks.onPress(self,y)return true else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function Header:hide(G)assert(type(G)=='boolean','Header.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Header.__index=Header;Label={}function Label.new(T,U,V,a9,aa,W)assert(type(T)=='number','Label.new: x must be a number, got '..type(T))assert(type(U)=='number','Label.new: y must be a number, got '..type(U))V=tostring(V)a9=tonumber(a9)aa=tonumber(aa)if not a9 then a9=globalTextColor end;_newLabel={text=V,hidden=false,pos={x=T,y=U},colors={textColor=a9,backgroundTextColor=aa,transparentBG=W},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newLabel,Label)return _newLabel end;function Label:draw()if not self.hidden then self.callbacks.onDraw(self)local k=globalTextColor;local Q=globalBackgroundTextColor;local ab=globalMonitor.getBackgroundColor()setTextColor(self.colors.textColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(ab)end;text(self.pos.x,self.pos.y,self.text,self.colors.transparentBG)setTextColor(k)setBackgroundTextColor(Q)end end;function Label:setCallback(y,z)assert(type(z)=='function','Label.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z end end;function Label:touch(T,U,y,a7)assert(type(T)=='number','Label.touch: x must be a number, got '..type(T))assert(type(U)=='number','Label.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then local _=self.pos.x+string.len(self.text)-1;if checkAreaPress(self.pos.x,self.pos.y,_,self.pos.y,T,U)then self.callbacks.onPress(self,y)return true else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function Label:hide(G)assert(type(G)=='boolean','Label.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Label.__index=Label;Button={}function Button.new(Y,Z,_,a0,V,a9,aa,ae,af)assert(type(Y)=='number','Button.new: x1 must be a number, got '..type(Y))assert(type(Z)=='number','Button.new: y1 must be a number, got '..type(Z))assert(type(_)=='number','Button.new: x2 must be a number, got '..type(_))assert(type(a0)=='number','Button.new: y2 must be a number, got '..type(a0))V=tostring(V)a9=tonumber(a9)aa=tonumber(aa)ae=tonumber(ae)af=tonumber(af)if not a9 then a9=globalTextColor end;if not ae then ae=globalColor end;if not af then af=globalColor end;_newButton={text=V,state=false,hidden=false,pos={x1=Y,y1=Z,x2=_,y2=a0},colors={textColor=a9,backgroundTextColor=aa,pressedButtonColor=ae,notPressedButtonColor=af},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newButton,Button)return _newButton end;function Button:draw()if not self.hidden then self.callbacks.onDraw(self)local a8=globalRectangleType;local R=globalColor;local k=globalTextColor;local Q=globalBackgroundTextColor;setRectangleType(rectangleTypes.filled)if self.state then setColor(self.colors.pressedButtonColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(self.colors.pressedButtonColor)end else setColor(self.colors.notPressedButtonColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(self.colors.notPressedButtonColor)end end;setTextColor(self.colors.textColor)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)local ag=self.pos.x1+math.floor((self.pos.x2-self.pos.x1-string.len(self.text)+1)/2)local ah=self.pos.y1+math.floor((self.pos.y2-self.pos.y1)/2)text(ag,ah,self.text)setRectangleType(a8)setColor(R)setTextColor(k)setBackgroundTextColor(Q)end end;function Button:setCallback(y,z)assert(type(z)=='function','Button.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z end end;function Button:touch(T,U,y,a7)assert(type(T)=='number','Button.touch: x must be a number, got '..type(T))assert(type(U)=='number','Button.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,T,U)then self.state=not self.state;self.callbacks.onPress(self,y)return true else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function Button:hide(G)assert(type(G)=='boolean','Button.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Button.__index=Button;Menu={}function Menu.new(Y,Z,_,a0,S)assert(type(Y)=='number','Menu.new: x1 must be a number, got '..type(Y))assert(type(Z)=='number','Menu.new: y1 must be a number, got '..type(Z))assert(type(_)=='number','Menu.new: x2 must be a number, got '..type(_))assert(type(a0)=='number','Menu.new: y2 must be a number, got '..type(a0))S=tonumber(S)if not S then S=globalColor end;_newMenu={color=S,objs={},hidden=true,pos={x1=Y,y1=Z,x2=_,y2=a0},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onButtonPress=function()end,onFailedButtonPress=function()end}}setmetatable(_newMenu,Menu)return _newMenu end;function Menu:draw()if not self.hidden then self.callbacks.onDraw(self)local a8=globalRectangleType;local R=globalColor;setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)for ai=#self.objs,1,-1 do local aj=self.objs[ai]aj:draw()end;setColor(R)end end;function Menu:setCallback(y,z)assert(type(z)=='function','Menu.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z elseif y==4 then self.callbacks.onButtonPress=z elseif y==5 then self.callbacks.onFailedButtonPress=z end end;function Menu:set(s,ak)for u,aj in pairs(s)do assert(getmetatable(aj)==Button,'Menu.set: you can only attach buttons to menus.')end;local al=math.abs(self.pos.x2-self.pos.x1)+1;local am=math.abs(self.pos.y2-self.pos.y1)+1;for ai=am+1,#s do table.remove(s,am+1)end;local an=math.floor(am/#s)local ao=math.min(self.pos.x1,self.pos.x2)local ap=math.max(self.pos.x1,self.pos.x2)local aq=math.min(self.pos.y1,self.pos.y2)local ar=math.max(self.pos.y1,self.pos.y2)for u,aj in pairs(s)do aj.pos.x1=ao;aj.pos.x2=ap;if ak then aj.pos.y1=aq+(u-1)*an;aj.pos.y2=aq+(u-1)*an+an-1 else aj.pos.y1=aq+u-1;aj.pos.y2=aq+u-1 end;aj.text=string.sub(aj.text,0,al)table.insert(self.objs,aj)end end;function Menu:touch(T,U,y,a7)assert(type(T)=='number','Menu.touch: x must be a number, got '..type(T))assert(type(U)=='number','Menu.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,T,U)then self.callbacks.onPress(self,y)local as=false;for u,aj in pairs(self.objs)do if aj:touch(T,U,y,as)then self.callbacks.onButtonPress(self,aj,y)as=true else self.callbacks.onFailedButtonPress(self,aj,y)end end;return as else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function Menu:hide(G)assert(type(G)=='boolean','Menu.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Menu.__index=Menu;PercentageBar={}function PercentageBar.new(Y,Z,_,a0,w,at,au,av,aw,ax,ay,az)assert(type(Y)=='number','PercentageBar.new: x1 must be a number, got '..type(Y))assert(type(Z)=='number','PercentageBar.new: y1 must be a number, got '..type(Z))assert(type(_)=='number','PercentageBar.new: x2 must be a number, got '..type(_))assert(type(a0)=='number','PercentageBar.new: y2 must be a number, got '..type(a0))assert(type(w)=='number','PercentageBar.new: value must be a number, got '..type(w))assert(type(at)=='number','PercentageBar.new: min must be a number, got '..type(at))assert(type(au)=='number','PercentageBar.new: max must be a number, got '..type(au))aw=tonumber(aw)ax=tonumber(ax)ay=tonumber(ay)az=tonumber(az)if not aw then aw=globalTextColor end;if not ay then ay=globalColor end;_newPercentageBar={hidden=false,value={draw=av,drawOnPB=true,percentage=nil,current=nil,max=au,min=at},pos={x1=Y,y1=Z,x2=_,y2=a0},colors={valueColor=aw,backgroundValueColor=ax,barColor=ay,backgroundBarColor=az},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}PercentageBar.setValue(_newPercentageBar,w)setmetatable(_newPercentageBar,PercentageBar)return _newPercentageBar end;function PercentageBar:draw()if not self.hidden then self.callbacks.onDraw(self)local a8=globalRectangleType;local R=globalColor;local k=globalTextColor;local Q=globalBackgroundTextColor;local ab=globalMonitor.getBackgroundColor()setRectangleType(rectangleTypes.filled)local aA=self.pos.x1+(self.pos.x2-self.pos.x1)*self.value.percentage/100;if self.colors.backgroundBarColor then setColor(self.colors.backgroundBarColor)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)if self.value.percentage>0 then setColor(self.colors.barColor)rectangle(self.pos.x1,self.pos.y1,aA,self.pos.y2)end else if self.value.percentage>0 then setColor(self.colors.barColor)rectangle(self.pos.x1,self.pos.y1,aA,self.pos.y2)end end;if self.value.draw then local aB=self.value.percentage..'%'local aC=self.pos.x1+math.floor((self.pos.x2-self.pos.x1-string.len(aB)+1)/2)local aD;if self.value.drawOnPB then aD=self.pos.y1+math.floor((self.pos.y2-self.pos.y1)/2)else if self.pos.y1>self.pos.y2 then aD=self.pos.y1+1 else aD=self.pos.y2+1 end end;setTextColor(self.colors.valueColor)if self.colors.backgroundValueColor then setBackgroundTextColor(self.colors.backgroundValueColor)text(aC,aD,aB)else if self.value.drawOnPB then if self.colors.backgroundBarColor then setBackgroundTextColor(self.colors.backgroundBarColor)else setBackgroundTextColor(ab)end;if self.pos.x1<self.pos.x2 then local aE=math.floor(aA)-aC+1;if aE<0 then aE=0 elseif aE>string.len(aB)then aE=string.len(aB)end;if aE<string.len(aB)then text(aC,aD,aB)end;if aE>0 then setBackgroundTextColor(self.colors.barColor)text(aC,aD,string.sub(aB,1,aE))end else local aE=aC+string.len(aB)-math.ceil(aA)if aE<0 then aE=0 elseif aE>string.len(aB)then aE=string.len(aB)end;if aE<string.len(aB)then text(aC,aD,aB)end;if aE>0 then setBackgroundTextColor(self.colors.barColor)text(aC+string.len(aB)-aE,aD,string.sub(aB,-aE))end end else setBackgroundTextColor(ab)text(aC,aD,self.value.percentage..'%')end end end;setRectangleType(a8)setColor(R)setTextColor(k)setBackgroundTextColor(Q)end end;function PercentageBar:setCallback(y,z)assert(type(z)=='function','PercentageBar.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z end end;function PercentageBar:setValue(w)assert(type(w)=='number','PercentageBar.setValue: value must be a number, got '..type(w))if w<self.value.min then w=self.value.min end;if w>self.value.max then w=self.value.max end;self.value.current=w;self.value.percentage=math.floor((self.value.current-self.value.min)/(self.value.max-self.value.min)*100)end;function PercentageBar:touch(T,U,y,a7)assert(type(T)=='number','PercentageBar.touch: x must be a number, got '..type(T))assert(type(U)=='number','PercentageBar.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,T,U)then self.callbacks.onPress(self,y)return true else self.callbacks.onFailedPress(self,y)return false end else self.callbacks.onFailedPress(self,y)end end;return false end;function PercentageBar:hide(G)assert(type(G)=='boolean','PercentageBar.hide: bool must be a boolean, got '..type(G))self.hidden=G end;PercentageBar.__index=PercentageBar;Memo={}function Memo.new(Y,Z,_,a0,a9,aa,S,aF)assert(type(Y)=='number','Memo.new: x1 must be a number, got '..type(Y))assert(type(Z)=='number','Memo.new: y1 must be a number, got '..type(Z))assert(type(_)=='number','Memo.new: x2 must be a number, got '..type(_))assert(type(a0)=='number','Memo.new: y2 must be a number, got '..type(a0))a9=tonumber(a9)aa=tonumber(aa)S=tonumber(S)aF=tonumber(aF)if not a9 then a9=globalTextColor end;if not S then S=globalColor end;if not aa then aa=S end;if not aF then aF=colors.white end;_newMemo={active=false,hidden=false,selfLoop=false,lines={},pos={x1=Y,y1=Z,x2=_,y2=a0},editSettings={editable=true,charEvent=true,keyEvent=true},cursor={text=' ',colors={textColor=a9,backgroundTextColor=aF},visible=false,blink={automatic=true,enabled=false,clock=os.clock(),speed=0.5},pos={char=1,line=1},limits={enabled=true,char=math.abs(_-Y)+1,line=math.abs(a0-Z)+1}},colors={textColor=a9,backgroundTextColor=aa,color=S},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onEdit=function()end,onCursorBlink=function()end,onActivated=function()end,onDeactivated=function()end}}setmetatable(_newMemo,Memo)return _newMemo end;function Memo:draw()if not self.hidden then self.callbacks.onDraw(self)local a8=globalRectangleType;local R=globalColor;local k=globalTextColor;local Q=globalBackgroundTextColor;local ab=globalMonitor.getBackgroundColor()local aG=math.min(self.pos.x1,self.pos.x2)local aH=math.max(self.pos.x1,self.pos.x2)local aI=math.min(self.pos.y1,self.pos.y2)local aJ=math.max(self.pos.y1,self.pos.y2)setRectangleType(rectangleTypes.filled)setColor(self.colors.color)setTextColor(self.colors.textColor)setBackgroundTextColor(self.colors.backgroundTextColor)rectangle(aG,aI,aH,aJ)local aK=aH-aG;local aL=aJ-aI;local aM={x=self.cursor.pos.char-1,y=self.cursor.pos.line-1}if aM.x>aK then aM.x=aK elseif aM.x<0 then aM.x=0 end;if aM.y>aL then aM.y=aL elseif aM.y<0 then aM.y=0 end;for ai=0,math.abs(aJ-aI)do if self.cursor.pos.line-1<=aL then if self.lines[ai+1]then if self.cursor.pos.char-1<=aK then text(aG,aI+ai,string.sub(self.lines[ai+1],1,aK+1))else text(aG,aI+ai,string.sub(self.lines[ai+1],self.cursor.pos.char-aK,self.cursor.pos.char))end end else if self.lines[ai+self.cursor.pos.line-aL]then if self.cursor.pos.char-1<=aK then text(aG,aI+ai,string.sub(self.lines[ai+self.cursor.pos.line-aL],1,aK+1))else text(aG,aI+ai,string.sub(self.lines[ai+self.cursor.pos.line-aL],self.cursor.pos.char-aK,self.cursor.pos.char))end end end end;if self.cursor.visible then setTextColor(self.cursor.colors.textColor)setBackgroundTextColor(self.cursor.colors.backgroundTextColor)text(aG+aM.x,aI+aM.y,self.cursor.text)end;setRectangleType(a8)setColor(R)setTextColor(k)setBackgroundTextColor(Q)end end;function Memo:setCallback(y,z)assert(type(z)=='function','Memo.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z elseif y==4 then self.callbacks.onEdit=z elseif y==5 then self.callbacks.onCursorBlink=z elseif y==6 then self.callbacks.onActivated=z elseif y==7 then self.callbacks.onDeactivated=z end end;function Memo:setCursorLimits(aN,aO)assert(type(aN)=='number'or type(aN)=='nil','Memo.setCursorLimits: char must be a number or nil, got '..type(aN))assert(type(aO)=='number'or type(aO)=='nil','Memo.setCursorLimits: line must be a number or nil, got '..type(aO))self.cursor.limits.char=aN;self.cursor.limits.line=aO end;function Memo:setCursorPos(aN,aO,aP)assert(type(aN)=='number','Memo.setCursorPos: char must be a number, got '..type(aN))assert(type(aO)=='number','Memo.setCursorPos: line must be a number, got '..type(aO))if aN<1 then aN=1 end;if aO<1 then aO=1 end;if self.cursor.limits.enabled then if self.cursor.limits.char then if aN>self.cursor.limits.char+1 then aN=self.cursor.limits.char end end;if self.cursor.limits.line then if aO>self.cursor.limits.line then aO=self.cursor.limits.line end end end;if not self.lines[aO]then if aP then for ai=#self.lines+1,aO do table.insert(self.lines,'')end else if#self.lines>0 then aO=#self.lines else aO=1 end end end;if self.lines[aO]then if aN>#self.lines[aO]+1 then aN=#self.lines[aO]+1 end else aN=1 end;self.cursor.pos.char=aN;self.cursor.pos.line=aO end;function Memo:edit(y)if not self.editSettings.editable then return end;if not self.hidden then local function aQ(event)if not event then return false end;if not self.lines[1]then self:setCursorPos(1,1,true)end;self.callbacks.onEdit(self,event)if self.cursor.limits.enabled then if self.cursor.limits.line then if#self.lines>self.cursor.limits.line then for ai=self.cursor.limits.line+1,#self.lines+1 do table.remove(self.lines,self.cursor.limits.line)end end end;for u,v in pairs(self.lines)do if self.cursor.limits.char then if#v>self.cursor.limits.char then self.lines[u]=v:sub(1,self.cursor.limits.char)end end end end;if event[1]=='monitor_touch'and(event[2]==globalMonitorName or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,event[2]))then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,event[3],event[4])then return true else return false end elseif event[1]=='mouse_click'and(globalMonitorName=='term'or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,'term'))then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,event[3],event[4])then return true else return false end elseif event[1]=='char'and self.editSettings.charEvent then local aR=self.lines[self.cursor.pos.line]if self.cursor.limits.enabled then if self.cursor.limits.char then if self.cursor.pos.char<=self.cursor.limits.char then self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)..event[2]..aR:sub(self.cursor.pos.char,#aR)self.cursor.pos.char=self.cursor.pos.char+1 end else self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)..event[2]..aR:sub(self.cursor.pos.char,#aR)self.cursor.pos.char=self.cursor.pos.char+1 end else self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)..event[2]..aR:sub(self.cursor.pos.char,#aR)self.cursor.pos.char=self.cursor.pos.char+1 end elseif event[1]=='key'and self.editSettings.keyEvent then local aR=self.lines[self.cursor.pos.line]if event[2]==28 then if self.cursor.limits.enabled then if self.cursor.limits.line then if#self.lines+1<=self.cursor.limits.line then table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aR:sub(self.cursor.pos.char,#aR)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aR:sub(self.cursor.pos.char,#aR)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aR:sub(self.cursor.pos.char,#aR)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end elseif event[2]==14 then if self.cursor.pos.char>1 then self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-2)..aR:sub(self.cursor.pos.char,#aR)self.cursor.pos.char=self.cursor.pos.char-1 elseif self.cursor.pos.line>1 then local aS=#self.lines[self.cursor.pos.line-1]if self.cursor.limits.enabled then if self.cursor.limits.char then if aS+#aR<=self.cursor.limits.char then self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aR:sub(self.cursor.pos.char,#aR)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aS+1 end else self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aR:sub(self.cursor.pos.char,#aR)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aS+1 end else self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aR:sub(self.cursor.pos.char,#aR)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aS+1 end end elseif event[2]==211 then if self.cursor.pos.char>#aR then if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.char then if#self.lines[self.cursor.pos.line+1]+#aR<=self.cursor.limits.char then self.lines[self.cursor.pos.line]=aR..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end else self.lines[self.cursor.pos.line]=aR..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end else self.lines[self.cursor.pos.line]=aR..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end end else self.lines[self.cursor.pos.line]=aR:sub(0,self.cursor.pos.char-1)..aR:sub(self.cursor.pos.char+1,#aR)end elseif event[2]==203 then if self.cursor.pos.char>1 then self.cursor.pos.char=self.cursor.pos.char-1 else if self.cursor.pos.line>1 then self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end elseif event[2]==205 then if self.cursor.pos.char<=#aR then if self.cursor.limits.enabled then if self.cursor.limits.char then if self.cursor.pos.char<=self.cursor.limits.char then self.cursor.pos.char=self.cursor.pos.char+1 end else self.cursor.pos.char=self.cursor.pos.char+1 end else self.cursor.pos.char=self.cursor.pos.char+1 end else if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.line then if self.cursor.pos.line<self.cursor.limits.line then self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end end end elseif event[2]==200 then if self.cursor.pos.line>1 then self.cursor.pos.line=self.cursor.pos.line-1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end elseif event[2]==208 then if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.line then if self.cursor.pos.line<self.cursor.limits.line then self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end else self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end else self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end end end end;return true end;if not self.selfLoop then aQ(y)else self.active=true;while self.active do local aT=os.startTimer(self.cursor.blink.speed/2)y={os.pullEvent()}if not aQ(y)then break end;self:draw()if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()end;if self.cursor.blink.enabled then if os.clock()>=self.cursor.blink.clock+self.cursor.blink.speed then self.cursor.blink.clock=os.clock()self.callbacks.onCursorBlink(self,y)self.cursor.visible=not self.cursor.visible end end;os.cancelTimer(aT)end end end end;function Memo:touch(T,U,y,a7)assert(type(T)=='number','Memo.touch: x must be a number, got '..type(T))assert(type(U)=='number','Memo.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 and checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,T,U)then self.callbacks.onPress(self,y)self.active=true;self.callbacks.onActivated(self,y)if self.selfLoop then self.cursor.blink.enabled=true;self.cursor.visible=true;self:edit(y)self.active=false;self.callbacks.onDeactivated(self,y)self.cursor.blink.enabled=false;self.cursor.visible=false elseif self.editSettings.editable and self.cursor.blink.automatic then self.cursor.blink.enabled=true;self.cursor.visible=true end;return true else self.callbacks.onFailedPress(self,y)if self.active then self.active=false;self.callbacks.onDeactivated(self,y)if self.editSettings.editable and self.cursor.blink.automatic then self.cursor.blink.enabled=false;self.cursor.visible=false end end;return false end end;if self.active then self.active=false;self.callbacks.onDeactivated(self,y)end;return false end;function Memo:tick(y)if not self.hidden then if not self.selfLoop then if self.cursor.blink.enabled then if os.clock()>=self.cursor.blink.clock+self.cursor.blink.speed then self.cursor.blink.clock=os.clock()self.callbacks.onCursorBlink(self,y)self.cursor.visible=not self.cursor.visible end end end end end;function Memo:key(y)if not self.hidden then if not self.selfLoop then if self.active then self:edit(y)end end end end;function Memo:char(y)if not self.hidden then if not self.selfLoop then if self.active then self:edit(y)end end end end;function Memo:write(o)if not o then o=''end;o=tostring(o)if not self.lines[1]then self:setCursorPos(1,1,true)end;self.callbacks.onEdit(self,{'write',o})local X=stringSplit(o,'\n')for u,v in pairs(X)do if u~=1 then if self.lines[self.cursor.pos.line+1]then self:setCursorPos(#self.lines[self.cursor.pos.line+1],self.cursor.pos.line+1)else self:setCursorPos(1,self.cursor.pos.line+1,true)end end;local aR=self.lines[self.cursor.pos.line]aR=aR:sub(0,self.cursor.pos.char-1)..v..aR:sub(self.cursor.pos.char,#aR)self.lines[self.cursor.pos.line]=aR;self:setCursorPos(self.cursor.pos.char+#v,self.cursor.pos.line)if self.cursor.limits.enabled then if self.cursor.limits.char then if#aR>self.cursor.limits.char then aR=aR:sub(1,self.cursor.limits.char)end end end;self.lines[self.cursor.pos.line]=aR end end;function Memo:print(o)if not o then o=''end;o=tostring(o)self:write(o..'\n')end;function Memo:clear()self.cursor.pos.char=1;self.cursor.pos.line=1;self.lines={}end;function Memo:enableSelfLoop(G)assert(type(G)=='boolean','Memo.enableSelfLoop: bool must be a boolean, got '..type(G))self.selfLoop=G end;function Memo:limits(G)assert(type(G)=='boolean','Memo.limits: bool must be a boolean, got '..type(G))self.cursor.limits.enabled=G end;function Memo:editable(G)assert(type(G)=='boolean','Memo.editable: bool must be a boolean, got '..type(G))self.editSettings.editable=G end;function Memo:hide(G)assert(type(G)=='boolean','Memo.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Memo.__index=Memo;Window={}function Window.new(Y,Z,_,a0,S)assert(type(Y)=='number','Window.new: x1 must be a number, got '..type(Y))assert(type(Z)=='number','Window.new: y1 must be a number, got '..type(Z))assert(type(_)=='number','Window.new: x2 must be a number, got '..type(_))assert(type(a0)=='number','Window.new: y2 must be a number, got '..type(a0))S=tonumber(S)if not S then S=term.getBackgroundColor()end;_newWindow={active=false,hidden=false,color=S,grabbedFrom={x=1,y=1},shadow={enabled=false,color=colors.black,offset={x=1,y=1}},objs={list={},events={draw={},touch={},tick={},key={},char={},mouse_drag={}}},pos={x1=Y,y1=Z,x2=_,y2=a0},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onOBJPress=function()end,onFailedOBJPress=function()end,onEvent=function()end}}setmetatable(_newWindow,Window)return _newWindow end;function Window:draw()if not self.hidden then self.callbacks.onDraw(self)local a8=globalRectangleType;local R=globalColor;setRectangleType(rectangleTypes.filled)if self.shadow.enabled then setColor(self.shadow.color)local aU=self.shadow.offset.x;local aV=self.shadow.offset.y;local aW=self.pos.x1+aU;local aX=self.pos.x2+aU;local aY=self.pos.y1+aV;local aZ=self.pos.y2+aV;rectangle(aW,aY,aX,aZ)end;setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)setRectangleType(a8)setColor(R)for C,aj in pairs(self.objs.events.draw)do aj:draw()end end end;function Window:setCallback(y,z)assert(type(z)=='function','Window.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onPress=z elseif y==3 then self.callbacks.onFailedPress=z elseif y==4 then self.callbacks.onOBJPress=z elseif y==5 then self.callbacks.onFailedOBJPress=z elseif y==6 then self.callbacks.onEvent=z end end;function Window:set(a_)assert(type(a_)=='table','Window.set: objGroup must be a table, got '..type(a_))self.objs.list=a_;self.objs.events=getOBJSEvents(a_)end;function Window:touch(T,U,y,a7)assert(type(T)=='number','Window.touch: x must be a number, got '..type(T))assert(type(U)=='number','Window.touch: y must be a number, got '..type(U))if not self.hidden then self.callbacks.onEvent(self,y)if not a7 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,T,U)then self.active=true;self.grabbedFrom.x=T;self.grabbedFrom.y=U;self.callbacks.onPress(self,y)local as=false;for C,aj in pairs(self.objs.events.touch)do if aj:touch(T,U,y,as)then self.callbacks.onOBJPress(self,aj,y)as=true else self.callbacks.onFailedOBJPress(self,aj,y)end end;return true else self.active=false;self.callbacks.onFailedPress(self,y)return false end else self.active=false;self.callbacks.onFailedPress(self,y)end end;return false end;function Window:mouse_drag(y)if not self.hidden then self.callbacks.onEvent(self,y)if self.active then local b0=y[3]-self.grabbedFrom.x;local b1=y[4]-self.grabbedFrom.y;self.grabbedFrom.x=y[3]self.grabbedFrom.y=y[4]self.pos.x1=self.pos.x1+b0;self.pos.x2=self.pos.x2+b0;self.pos.y1=self.pos.y1+b1;self.pos.y2=self.pos.y2+b1;for C,aj in pairs(self.objs.list)do if aj.pos.x then aj.pos.x=aj.pos.x+b0 end;if aj.pos.x1 then aj.pos.x1=aj.pos.x1+b0 end;if aj.pos.x2 then aj.pos.x2=aj.pos.x2+b0 end;if aj.pos.y then aj.pos.y=aj.pos.y+b1 end;if aj.pos.y1 then aj.pos.y1=aj.pos.y1+b1 end;if aj.pos.y2 then aj.pos.y2=aj.pos.y2+b1 end end end end end;function Window:tick(y)if not self.hidden then self.callbacks.onEvent(self,y)for u,aj in pairs(self.objs.events.tick)do aj:tick(y)end end end;function Window:key(y)if not self.hidden then self.callbacks.onEvent(self,y)for u,aj in pairs(self.objs.events.key)do aj:key(y)end end end;function Window:char(y)if not self.hidden then self.callbacks.onEvent(self,y)for u,aj in pairs(self.objs.events.char)do aj:char(y)end end end;function Window:hide(G)assert(type(G)=='boolean','Window.hide: bool must be a boolean, got '..type(G))self.hidden=G end;Window.__index=Window;OBJGroup={}function OBJGroup.new()_newOBJGroup={objs={list={},events={draw={},touch={},tick={},key={},char={},mouse_drag={}}},hidden=false,callbacks={onDraw=function()end,onOBJPress=function()end,onFailedOBJPress=function()end}}setmetatable(_newOBJGroup,OBJGroup)return _newOBJGroup end;function OBJGroup:draw()if not self.hidden then self.callbacks.onDraw(self)for C,aj in pairs(self.objs.events.draw)do aj:draw()end end end;function OBJGroup:setCallback(y,z)assert(type(z)=='function','OBJGroup.setCallback: callback must be a function, got '..type(z))if y==1 then self.callbacks.onDraw=z elseif y==2 then self.callbacks.onOBJPress=z elseif y==3 then self.callbacks.onFailedOBJPress=z end end;function OBJGroup:set(a_)assert(type(a_)=='table','OBJGroup.set: objGroup must be a table, got '..type(a_))self.objs.list=a_;self.objs.events=getOBJSEvents(a_)end;function OBJGroup:touch(T,U,y,a7)assert(type(T)=='number','OBJGroup.touch: x must be a number, got '..type(T))assert(type(U)=='number','OBJGroup.touch: y must be a number, got '..type(U))if not self.hidden then if not a7 then local as=false;for C,aj in pairs(self.objs.list)do if aj:touch(T,U,y,as)then self.callbacks.onOBJPress(self,aj,y)as=true else self.callbacks.onFailedOBJPress(self,aj,y)end end;return as end end;return false end;function OBJGroup:tick(y)if not self.hidden then for u,aj in pairs(self.objs.events.tick)do aj:tick(y)end end end;function OBJGroup:key(y)if not self.hidden then for u,aj in pairs(self.objs.events.key)do aj:key(y)end end end;function OBJGroup:char(y)if not self.hidden then for u,aj in pairs(self.objs.events.char)do aj:char(y)end end end;function OBJGroup:mouse_drag(y)if not self.hidden then for u,aj in pairs(self.objs.events.mouse_drag)do aj:mouse_drag(y)end end end;function OBJGroup:hide(G)assert(type(G)=='boolean','OBJGroup.hide: bool must be a boolean, got '..type(G))self.hidden=G end;OBJGroup.__index=OBJGroup;globalLoop.stats.FPS=Label.new(0,0,'0FPS',nil,nil,true)globalLoop.stats.EPS=Label.new(0,0,'0EPS',nil,nil,true)globalLoop.stats.FPS.hidden=true;globalLoop.stats.EPS.hidden=true;table.insert(globalLoop.group.LIBPrivate.objs,globalLoop.stats.FPS)table.insert(globalLoop.group.LIBPrivate.objs,globalLoop.stats.EPS)function drawOnLoopClock()globalLoop.drawOnClock=true end;function drawOnLoopEvent()globalLoop.drawOnClock=false end;function drawLoopStats(G)assert(type(G)=='boolean','enableLoopStats: bool must be a boolean, got '..type(G))if G and globalLoop.stats.automaticPos then local b2=globalLoop.stats.automaticPosOffset.x;local b3=globalLoop.stats.automaticPosOffset.y;globalLoop.stats.FPS.pos.x=globalMonitorWidth-#globalLoop.stats.FPS.text+1+b2;globalLoop.stats.FPS.pos.y=globalMonitorHeight-1+b3;globalLoop.stats.EPS.pos.x=globalMonitorWidth-#globalLoop.stats.EPS.text+1+b2;globalLoop.stats.EPS.pos.y=globalMonitorHeight+b3 end;globalLoop.stats.FPS.hidden=not G;globalLoop.stats.EPS.hidden=not G end;function setLoopClockSpeed(b4)assert(type(b4)=='number','setLoopClockSpeed: sec must be a number, got '..type(b4))globalLoop.clockSpeed=b4 end;function setLoopTimerSpeed(b4)assert(type(b4)=='number','setLoopTimerSpeed: sec must be a number, got '..type(b4))globalLoop.timerSpeed=b4 end;function setLoopCallback(y,z)assert(type(z)=='function','setLoopCallback: callback must be a function, got '..type(z))if y==1 then globalLoop.callbacks.onInit=z elseif y==2 then globalLoop.callbacks.onStop=z elseif y==3 then globalLoop.callbacks.onClock=z elseif y==4 then globalLoop.callbacks.onEvent=z elseif y==5 then globalLoop.callbacks.onTimer=z elseif y==6 then globalLoop.callbacks.onMonitorChange=z end end;function loopAutoClear(G)assert(type(G)=='boolean','loopAutoClear: bool must be a boolean, got '..type(G))globalLoop.autoClear=G end;function addLoopGroup(b5,b6)b5=tostring(b5)assert(b5~='LIBPrivate'or b5~='none',"addLoopGroup: can't overwrite Lib's Private groups")assert(type(b6)=='table','addLoopGroup: group must be a table, got '..type(b6))globalLoop.group[b5]={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs=b6}end;function removeLoopGroup(b5)b5=tostring(b5)assert(b5~='LIBPrivate'or b5~='none',"removeLoopGroup: can't remove Lib's Private groups")globalLoop.group[b5]=nil end;function setLoopGroup(b5)b5=tostring(b5)assert(globalLoop.group[b5],'setLoopGroup: groupName must be a valid group.')local b7=globalLoop.group[globalLoop.selectedGroup]local b8=globalLoop.group[b5]b7.callbacks.onUnset(b7,b8)globalLoop.selectedGroup=b5;b8.callbacks.onSet(b8,b7)globalLoop.wasGroupChanged=true end;function setLoopGroupCallback(b5,y,z)b5=tostring(b5)assert(b5~='LIBPrivate'or b5~='none',"setLoopGroupCallback: can't overwrite Lib's Private groups' callbacks")assert(globalLoop.group[b5],'setLoopGroupCallback: groupName must be a valid group.')assert(type(z)=='function','setLoopGroupCallback: callback must be a function, got '..type(z))if y==1 then globalLoop.group[b5].callbacks.onClock=z elseif y==2 then globalLoop.group[b5].callbacks.onEvent=z elseif y==3 then globalLoop.group[b5].callbacks.onTimer=z elseif y==4 then globalLoop.group[b5].callbacks.onMonitorChange=z elseif y==5 then globalLoop.group[b5].callbacks.onSet=z elseif y==6 then globalLoop.group[b5].callbacks.onUnset=z end end;function resetLoopSettings()globalLoop.APLWDBroadcastOnClock=false;globalLoop.APLWDClearCacheOnDraw=true;globalLoop.stats.FPS.hidden=true;globalLoop.stats.EPS.hidden=true;globalLoop.callbacks.onInit=function()end;globalLoop.callbacks.onEvent=function()end;globalLoop.callbacks.onClock=function()end;globalLoop.selectedGroup='none'globalLoop.group={none={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}},LIBPrivate={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}}}globalLoop.events={draw={},touch={},tick={},key={},char={},mouse_drag={}}end;function stopLoop()globalLoop.enabled=false;globalLoop.callbacks.onStop()globalLoop.events={draw={},touch={},tick={},key={},char={},mouse_drag={}}end;function loop()globalLoop.enabled=true;if globalLoop.autoClear then bClearMonitorGroup()end;updateLoopEvents()globalLoop.callbacks.onInit()drawLoopOBJs()local b9=Clock.new(1)b9.FPS=0;b9.EPS=0;b9:setCallback(event.clock.onClock,function(self,event)globalLoop.stats.FPS.text=tostring(self.FPS)..'FPS'globalLoop.stats.EPS.text=tostring(self.EPS)..'EPS'if globalLoop.stats.automaticPos then local b2=globalLoop.stats.automaticPosOffset.x;local b3=globalLoop.stats.automaticPosOffset.y;globalLoop.stats.FPS.pos.x=globalMonitorWidth-#globalLoop.stats.FPS.text+1+b2;globalLoop.stats.FPS.pos.y=globalMonitorHeight-1+b3;globalLoop.stats.EPS.pos.x=globalMonitorWidth-#globalLoop.stats.EPS.text+1+b2;globalLoop.stats.EPS.pos.y=globalMonitorHeight+b3 end;self.FPS=0;self.EPS=0 end)local ba=os.clock()while globalLoop.enabled do if globalLoop.wasGroupChanged then updateLoopEvents()globalLoop.wasGroupChanged=false end;local aT=os.startTimer(globalLoop.timerSpeed)local event={os.pullEvent()}if event[1]=='monitor_touch'and(event[2]==globalMonitorName or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,event[2]))then touchLoopOBJs(event[3],event[4],event)elseif event[1]=='mouse_click'and(globalMonitorName=='term'or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,'term'))then touchLoopOBJs(event[3],event[4],event)elseif event[1]=='key'then for C,aj in pairs(globalLoop.events.key)do aj:key(event)end elseif event[1]=='char'then for C,aj in pairs(globalLoop.events.char)do aj:char(event)end elseif event[1]=='mouse_drag'then for C,aj in pairs(globalLoop.events.mouse_drag)do aj:mouse_drag(event)end elseif event[1]=='timer'then globalLoop.callbacks.onTimer(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onTimer(event)end;globalLoop.clock=os.clock()if globalLoop.clock>=ba+globalLoop.clockSpeed then ba=os.clock()if globalLoop.drawOnClock then if APLWD.enabled and globalLoop.APLWDClearCacheOnDraw then APLWD.clearCache()end;if globalLoop.autoClear and not globalMonitorBuffer.enabled then bClearMonitorGroup()end;globalLoop.callbacks.onClock(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onClock(event)drawLoopOBJs()b9.FPS=b9.FPS+1 else globalLoop.callbacks.onClock(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onClock(event)end;if APLWD.enabled and globalLoop.APLWDBroadcastOnClock then APLWD.broadcastCache()end end;if not globalLoop.drawOnClock then if APLWD.enabled and globalLoop.APLWDClearCacheOnDraw then APLWD.clearCache()end;if globalLoop.autoClear and not globalMonitorBuffer.enabled then bClearMonitorGroup()end;globalLoop.callbacks.onEvent(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onEvent(event)drawLoopOBJs()b9.FPS=b9.FPS+1 else globalLoop.callbacks.onEvent(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onEvent(event)end;for C,aj in pairs(globalLoop.events.tick)do aj:tick(event)end;b9:tick()b9.EPS=b9.EPS+1;os.cancelTimer(aT)end end;function getOBJSEvents(s)assert(type(s)=='table','getOBJSEvents: table must be a table, got '..type(s))local bb={draw={},touch={},tick={},key={},char={},mouse_drag={}}for C,aj in pairs(s)do if aj.draw then table.insert(bb.draw,1,aj)end;if aj.touch then table.insert(bb.touch,aj)end;if aj.tick then table.insert(bb.tick,aj)end;if aj.key then table.insert(bb.key,aj)end;if aj.char then table.insert(bb.char,aj)end;if aj.mouse_drag then table.insert(bb.mouse_drag,aj)end end;return bb end;function updateLoopEvents()local bc={}for C,aj in pairs(globalLoop.group.LIBPrivate.objs)do table.insert(bc,aj)end;for C,aj in pairs(globalLoop.group[globalLoop.selectedGroup].objs)do table.insert(bc,aj)end;globalLoop.events=getOBJSEvents(bc)end;function drawLoopOBJs()if globalMonitorGroup.enabled then if globalMonitorBuffer.enabled then globalMonitorBuffer.clear()end;globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)for u,aj in pairs(globalLoop.events.draw)do aj:draw()end;if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()end;local A=APLWD.cacheWritable;if APLWD.enabled and A then APLWD.cacheWritable=false end;local B=globalMonitorName;for C,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=B then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()else for u,aj in pairs(globalLoop.events.draw)do aj:draw()end end end end;setMonitor(B)if APLWD.enabled and A then APLWD.cacheWritable=true end else if globalMonitorBuffer.enabled then globalMonitorBuffer.clear()end;for u,aj in pairs(globalLoop.events.draw)do aj:draw()end;if globalMonitorBuffer.enabled then globalMonitorBuffer.draw()end end end;function touchLoopOBJs(T,U,y)assert(type(T)=='number','touchLoopOBJs: x must be a number, got '..type(T))assert(type(U)=='number','touchLoopOBJs: y must be a number, got '..type(U))local bd=false;for C,aj in pairs(globalLoop.events.touch)do if aj:touch(T,U,y,bd)then bd=true end end end;local be={...}if table.maxn(be)>0 then be[1]=string.lower(be[1])if be[1]=='ver'then print('Lib version: '..ver)elseif be[1]=='setup'then if shell then local bf='/'..shell.getRunningProgram()OSSettings.set('APLibPath',bf)print('Setup completed!\nAPLibPath: '..tostring(settings.get('APLibPath')))sleep(2)os.reboot()else error('Setup failed, shell API not available!')end elseif be[1]=='create'then if be[2]then local V='\n-- //AUTO-GENERATED-CODE//\nlocal APLibPath = settings.get(\'APLibPath\')\n\nassert(  -- check if setup was done before, if not return with an error\n    type(APLibPath) == \'string\',\n    \'Couldn\\\'t open APLib through path: \'..tostring(\n        APLibPath\n    )..\'; probably you haven\\\'t completed Lib setup via \\\'LIBFILE setup\\\' or the setup failed\'\n)\n\nassert( -- check if Lib is still there, if not return with an error\n    fs.exists(APLibPath),\n    \'Couldn\\\'t open APLib through path: \'..tostring(\n      	APLibPath\n    )..\'; remember that if you move the Lib\\\'s folder you must set it up again via \\\'LIBFILE setup\\\'\'\n)\n\nos.loadAPI(APLibPath) -- load Lib with CraftOS\'s built-in feature\n\nAPLibPath = fs.getName(APLibPath)\nif APLibPath:sub(#APLibPath - 3) == \'.lua\' then APLibPath = APLibPath:sub(1, #APLibPath - 4); end\nlocal APLib = _ENV[APLibPath]\nAPLibPath = nil\n-- //--//\n\n'local bg='/'..be[2]if fs.exists(bg)then print('Are you sure you want to overwrite: '..bg)print('Press ENTER to confirm or another key to cancel.')local event={os.pullEvent('key')}if event[2]==28 then local bh=fs.open(bg,'w')if bh then bh.write(V)bh.close()print('File succesfully created!')else print('Couldn\'t create file.')end else print('File wasn\'t created!')end else local bh=fs.open(bg,'w')if bh then bh.write(V)bh.close()print('File succesfully created!')else print('Couldn\'t create file.')end end else print('You must specify the name of the file you want to create.')end end end