info={ver='1.21.0',author='hds536jhmk',website='https://github.com/hds536jhmk/APLib'}globalMonitor=term;globalMonitorName='term'globalMonitorGroup={enabled=false,list={}}globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()globalColor=colors.white;globalTextColor=colors.white;globalBackgroundTextColor=colors.black;globalRectangleType=1;globalLoop={enabled=false,autoClear=true,drawOnClock=true,clockSpeed=0.5,timerSpeed=0.1,clock=0,APLWDBroadcastOnClock=false,APLWDClearCacheOnDraw=true,stats={automaticPos=true,automaticPosOffset={x=0,y=0}},callbacks={onInit=function()end,onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end},events={draw={},touch={},tick={},key={},char={},mouse_drag={}},wasGroupChanged=false,selectedGroup='none',group={none={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}},LIBPrivate={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}}}}globalCallbacks={onBClear=function()end,onSetMonitor=function()end}rectangleTypes={filled=1,hollow=2,checker=3}event={global={onBClear=1,onSetMonitor=2},clock={onClock=1},point={onDraw=1,onPress=2,onFailedPress=3},rectangle={onDraw=1,onPress=2,onFailedPress=3},header={onDraw=1,onPress=2,onFailedPress=3},label={onDraw=1,onPress=2,onFailedPress=3},button={onDraw=1,onPress=2,onFailedPress=3},menu={onDraw=1,onPress=2,onFailedPress=3,onButtonPress=4,onFailedButtonPress=5},percentagebar={onDraw=1,onPress=2,onFailedPress=3},memo={onDraw=1,onPress=2,onFailedPress=3,onEdit=4,onCursorBlink=5,onActivated=6,onDeactivated=7},window={onDraw=1,onPress=2,onFailedPress=3,onOBJPress=4,onFailedOBJPress=5,onEvent=6},objGroup={onDraw=1,onOBJPress=2,onFailedOBJPress=3},loop={group={onClock=1,onEvent=2,onTimer=3,onMonitorChange=4,onSet=5,onUnset=6},onInit=1,onClock=2,onEvent=3,onTimer=4,onMonitorChange=5}}function stringSplit(a,b)a=tostring(a)b=tostring(b)local c={}while true do local d=a:find(b)if d then table.insert(c,a:sub(1,d-1))a=a:sub(d+1)else table.insert(c,a)break end end;return c end;function tablesAreEqual(e,f)assert(type(e)=='table','tablesAreEqual: t1 must be a table, got '..type(e))assert(type(f)=='table','tablesAreEqual: t2 must be a table, got '..type(f))local function g(e,f,h)if#e~=#f then return false end;for i,j in pairs(e)do if type(j)=='table'and type(f[i])=='table'then g(j,f[i])elseif j~=f[i]then return false end end;return h or g(f,e,true)end;return g(e,f)end;function tableHasKey(k,l)assert(type(k)=='table','tableHasKey: table must be a table, got '..type(k))assert(type(l)=='string'or type(l)=='number','tableHasKey: key must be a string or a number, got '..type(l))for i,j in pairs(k)do if i==l then return true,j end end;return false end;function tableHasValue(k,m)assert(type(k)=='table','tableHasValue: table must be a table, got '..type(k))for i,j in pairs(k)do if j==m then return true,i end end;return false end;OSSettings={settingsPath='/.settings',set=function(n,m)assert(type(m)~='nil',"OSSettings.set: value can't be nil, got "..type(m))settings.set(tostring(n),m)return settings.save(OSSettings.settingsPath)end,get=function(n)return settings.get(tostring(n))end,getNames=function()return settings.getNames()end,unset=function(n)settings.unset(tostring(n))return settings.save(OSSettings.settingsPath)end}function setGlobalCallback(o,p)assert(type(p)=='function','setGlobalCallback: callback must be a function, got '..type(p))if o==1 then globalCallbacks.onBClear=p elseif o==2 then globalCallbacks.onSetMonitor=p end end;function bClear()globalMonitor.clear()globalMonitor.setCursorPos(1,1)globalCallbacks.onBClear()if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='bClear'})end end;function bClearMonitorGroup()if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)bClear()local q=APLWD.cacheWritable;if APLWD.enabled and q then APLWD.cacheWritable=false end;local r=globalMonitorName;for s,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=r then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)bClear()end end;setMonitor(r)if APLWD.enabled and q then APLWD.cacheWritable=true end else bClear()end end;function setMonitor(t)t=tostring(t)globalCallbacks.onSetMonitor(globalMonitor,globalMonitorName,globalMonitorWidth,globalMonitorHeight)if t=='term'then globalMonitor=term;globalMonitorName='term'globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()else assert(tostring(peripheral.getType(t))=='monitor','setMonitor: monitorName must be a monitor, got '..tostring(peripheral.getType(t)))local u=peripheral.wrap(t)globalMonitor=u;globalMonitorName=t;globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()end end;function getMonitorSize()return globalMonitorWidth,globalMonitorHeight end;function setMonitorGroup(v)assert(type(v)=='table','setMonitorGroup: monitorNameList must be a table, got '..type(v))for i,j in pairs(v)do j=tostring(j)if not j=='term'then assert(tostring(peripheral.getType(j))=='monitor','setMonitorGroup: '..j..' must be a monitor, got '..tostring(peripheral.getType(j)))end end;globalMonitorGroup.list=v end;function setMonitorGroupEnabled(w)assert(type(w)=='boolean','setMonitorGroupEnabled: bool must be a boolean, got '..type(w))globalMonitorGroup.enabled=w end;function resetMonitorGroup()globalMonitorGroup.list={}end;APLWD={enabled=false,cacheWritable=true,clearOnDraw=false,protocol='APLWD-'..info.ver,senderName='SendeR',receiverName='ReceiveR',isReceiver=true,myName='',senderID='',modemName='',cache={}}APLWD.enable=function(w)assert(type(w)=='boolean','APLWD.enable: bool must be a boolean, got '..type(w))APLWD.enabled=w end;APLWD.broadcastOnLoopClock=function()globalLoop.APLWDBroadcastOnClock=true end;APLWD.dontBroadcastOnLoopClock=function()globalLoop.APLWDBroadcastOnClock=false end;APLWD.enableClearCacheOnLoopDraw=function(w)assert(type(w)=='boolean','APLWD.enableClearCacheOnLoopDraw: bool must be a boolean, got '..type(w))globalLoop.APLWDClearCacheOnDraw=w end;APLWD.host=function(x,y)if APLWD.enabled then x=tostring(x)if y then y=tostring(y)else y=tostring(os.getComputerID())end;assert(tostring(peripheral.getType(x))=='modem','APLWD.host: modemName must be a modem, got '..tostring(peripheral.getType(x)))rednet.open(x)if rednet.lookup(APLWD.protocol,APLWD.senderName..y)then rednet.close(x)error("APLWD.host: There's already someone connected with hostname: "..y)end;rednet.host(APLWD.protocol,APLWD.senderName..y)APLWD.isReceiver=false;APLWD.myName=APLWD.senderName..y;APLWD.modemName=x end end;APLWD.connect=function(x,z,y)if APLWD.enabled then x=tostring(x)if y then y=tostring(y)else y=tostring(os.getComputerID())end;z=tostring(z)assert(tostring(peripheral.getType(x))=='modem','APLWD.connect: modemName must be a modem, got '..tostring(peripheral.getType(x)))rednet.open(x)if rednet.lookup(APLWD.protocol,APLWD.receiverName..y)then rednet.close(x)error("APLWD.connect: There's already someone connected with hostname: "..y)end;local A=rednet.lookup(APLWD.protocol,APLWD.senderName..z)if not A then rednet.close(x)error("APLWD.connect: Didn't find any sender with name: "..z)end;rednet.host(APLWD.protocol,APLWD.receiverName..y)APLWD.isReceiver=true;APLWD.myName=APLWD.receiverName..y;APLWD.senderID=A;APLWD.modemName=x end end;APLWD.close=function()if APLWD.modemName~=''then if not APLWD.isReceiver then rednet.broadcast('disconnected',APLWD.protocol)end;rednet.unhost(APLWD.protocol,APLWD.myName)rednet.close(APLWD.modemName)APLWD.enable(false)APLWD.clearCache()APLWD.isReceiver=true;APLWD.myName=''APLWD.senderID=''APLWD.modemName=''end end;APLWD.broadcastCache=function()if APLWD.enabled then local B=rednet.isOpen()assert(B,'APLWD.broadcastCache: rednet connection must be opened first, connection '..tostring(B))rednet.broadcast(APLWD.cache,APLWD.protocol)APLWD.clearCache()end end;APLWD.receiveCache=function(C)if APLWD.enabled then local B=rednet.isOpen()assert(B,'APLWD.receiveCache: rednet connection must be opened first, connection '..tostring(B))local A,D,E=rednet.receive(APLWD.protocol,tonumber(C))if type(D)=='table'then if A==APLWD.senderID then APLWD.cache=D;return true end elseif D=='disconnected'then APLWD.close()return false,'disconnected'end;return false end end;APLWD.drawCache=function()if APLWD.enabled then local function F()for i,j in pairs(APLWD.cache)do if j.type=='bClear'then bClearMonitorGroup()elseif j.type=='background'then setBackgroundMonitorGroup(j.color)elseif j.type=='text'then local G=globalTextColor;local H=globalBackgroundTextColor;setTextColor(j.colors.textColor)setBackgroundTextColor(j.colors.backgroundTextColor)text(j.pos.x,j.pos.y,j.text)setTextColor(G)setBackgroundTextColor(H)elseif j.type=='point'then local I=globalColor;setColor(j.color)point(j.pos.x,j.pos.y)setColor(I)elseif j.type=='rectangle'then local I=globalColor;setColor(j.color)rectangle(j.pos.x1,j.pos.y1,j.pos.x2,j.pos.y2)setColor(I)end end end;if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)if APLWD.clearOnDraw then bClear()end;F()local r=globalMonitorName;for s,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=r then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)if APLWD.clearOnDraw then bClear()end;F()end end;setMonitor(r)else if APLWD.clearOnDraw then bClear()end;F()end;APLWD.clearCache()end end;APLWD.clearCache=function()APLWD.cache={}end;function setColor(J)assert(type(J)=='number','setColor: color must be a number, got '..type(J))globalColor=J end;function setTextColor(J)assert(type(J)=='number','setTextColor: color must be a number, got '..type(J))globalTextColor=J end;function setBackgroundTextColor(J)assert(type(J)=='number','setBackgroundTextColor: color must be a number, got '..type(J))globalBackgroundTextColor=J end;function setBackground(J)assert(type(J)=='number','setBackgroundColor: color must be a number, got '..type(J))globalMonitor.setBackgroundColor(J)local q=APLWD.cacheWritable;if APLWD.enabled and q then APLWD.cacheWritable=false end;bClear()if APLWD.enabled and q then APLWD.cacheWritable=true end;if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='background',color=J})end end;function setBackgroundMonitorGroup(J)assert(type(J)=='number','setBackgroundMonitorGroup: color must be a number, got '..type(J))if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)setBackground(J)local q=APLWD.cacheWritable;if APLWD.enabled and q then APLWD.cacheWritable=false end;local r=globalMonitorName;for s,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=r then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)setBackground(J)end end;setMonitor(r)if APLWD.enabled and q then APLWD.cacheWritable=true end else setBackground(J)end end;function setRectangleType(K)assert(type(K)=='number','setRectangleType: type must be a number, got '..type(K))globalRectangleType=K end;function text(L,M,N)assert(type(L)=='number','Text: x must be a number, got '..type(L))assert(type(M)=='number','Text: y must be a number, got '..type(M))N=tostring(N)local O,P=globalMonitor.getCursorPos()local G=globalMonitor.getTextColor()local Q=globalMonitor.getBackgroundColor()globalMonitor.setTextColor(globalTextColor)globalMonitor.setBackgroundColor(globalBackgroundTextColor)local R=stringSplit(N,'\n')for i,j in pairs(R)do globalMonitor.setCursorPos(L,M+i-1)globalMonitor.write(j)end;globalMonitor.setCursorPos(O,P)globalMonitor.setTextColor(G)globalMonitor.setBackgroundColor(Q)if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='text',text=N,pos={x=L,y=M},colors={textColor=globalTextColor,backgroundTextColor=globalBackgroundTextColor}})end end;function point(L,M)assert(type(L)=='number','Point: x must be a number, got '..type(L))assert(type(M)=='number','Point: y must be a number, got '..type(M))local O,P=globalMonitor.getCursorPos()globalMonitor.setCursorPos(L,M)local Q=globalMonitor.getBackgroundColor()globalMonitor.setBackgroundColor(globalColor)globalMonitor.write(' ')globalMonitor.setCursorPos(O,P)globalMonitor.setBackgroundColor(Q)if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='point',pos={x=L,y=M},color=globalColor})end end;function rectangle(S,T,U,V)assert(type(S)=='number','Point: x1 must be a number, got '..type(S))assert(type(T)=='number','Point: y1 must be a number, got '..type(T))assert(type(U)=='number','Point: x2 must be a number, got '..type(U))assert(type(V)=='number','Point: y2 must be a number, got '..type(V))local W=1;local X=1;if S>U then W=-1 end;if T>V then X=-1 end;local q=APLWD.cacheWritable;if APLWD.enabled and q then APLWD.cacheWritable=false end;if globalRectangleType==1 then for Y=S,U,W do for Z=T,V,X do point(Y,Z)end end elseif globalRectangleType==2 then for Y=S,U,W do point(Y,T)point(Y,V)end;for Z=T,V,X do point(S,Z)point(U,Z)end elseif globalRectangleType==3 then local _=true;for Y=S,U,W do for Z=T,V,X do if _ then point(Y,Z)end;_=not _ end;if math.abs(S-U)%2~=0 then _=not _ end end end;if APLWD.enabled and q then APLWD.cacheWritable=true end;if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='rectangle',pos={x1=S,y1=T,x2=U,y2=V},color=globalColor})end end;function checkAreaPress(S,T,U,V,a0,a1)assert(type(S)=='number','checkAreaPress: x1 must be a number, got '..type(S))assert(type(T)=='number','checkAreaPress: y1 must be a number, got '..type(T))assert(type(U)=='number','checkAreaPress: x2 must be a number, got '..type(U))assert(type(V)=='number','checkAreaPress: y2 must be a number, got '..type(V))assert(type(a0)=='number','checkAreaPress: xPressed must be a number, got '..type(a0))assert(type(a1)=='number','checkAreaPress: yPressed must be a number, got '..type(a1))if S<U then if not(a0>=S and a0<=U)then return false end else if not(a0<=S and a0>=U)then return false end end;if T<V then if not(a1>=T and a1<=V)then return false end else if not(a1<=T and a1>=V)then return false end end;return true end;Clock={}function Clock.new(a2)assert(type(a2)=='number','Clock.new: interval must be a number, got '..type(a2))_newClock={clock=os.clock(),interval=a2,callbacks={onClock=function()end}}setmetatable(_newClock,Clock)return _newClock end;function Clock:setCallback(o,p)assert(type(p)=='function','Clock.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onClock=p end end;function Clock:tick(o)if os.clock()>=self.clock+self.interval then self.clock=os.clock()self.callbacks.onClock(self,o)return true end;return false end;Clock.__index=Clock;Point={}function Point.new(L,M,J)assert(type(L)=='number','Point.new: x must be a number, got '..type(L))assert(type(M)=='number','Point.new: y must be a number, got '..type(M))J=tonumber(J)if not J then J=globalColor end;_newPoint={color=J,hidden=false,pos={x=L,y=M},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newPoint,Point)return _newPoint end;function Point:draw()if not self.hidden then self.callbacks.onDraw(self)local I=globalColor;setColor(self.color)point(self.pos.x,self.pos.y)setColor(I)end end;function Point:setCallback(o,p)assert(type(p)=='function','Point.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p end end;function Point:touch(L,M,o,a3)assert(type(L)=='number','Point.touch: x must be a number, got '..type(L))assert(type(M)=='number','Point.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then if self.pos.x==L and self.pos.y==M then self.callbacks.onPress(self,o)return true else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function Point:hide(w)assert(type(w)=='boolean','Point.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Point.__index=Point;Rectangle={}function Rectangle.new(S,T,U,V,J,K)assert(type(S)=='number','Rectangle.new: x1 must be a number, got '..type(S))assert(type(T)=='number','Rectangle.new: y1 must be a number, got '..type(T))assert(type(U)=='number','Rectangle.new: x2 must be a number, got '..type(U))assert(type(V)=='number','Rectangle.new: y2 must be a number, got '..type(V))J=tonumber(J)K=tonumber(K)if not J then J=globalColor end;if not K then K=globalRectangleType end;_newRectangle={color=J,type=K,hidden=false,pos={x1=S,y1=T,x2=U,y2=V},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newRectangle,Rectangle)return _newRectangle end;function Rectangle:draw()if not self.hidden then self.callbacks.onDraw(self)local a4=globalRectangleType;local I=globalColor;setRectangleType(self.type)setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)setRectangleType(a4)setColor(I)end end;function Rectangle:setCallback(o,p)assert(type(p)=='function','Rectangle.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p end end;function Rectangle:touch(L,M,o,a3)assert(type(L)=='number','Rectangle.touch: x must be a number, got '..type(L))assert(type(M)=='number','Rectangle.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,L,M)then self.callbacks.onPress(self,o)return true else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function Rectangle:hide(w)assert(type(w)=='boolean','Rectangle.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Rectangle.__index=Rectangle;Header={}function Header.new(M,N,a5,a6)assert(type(M)=='number','Header.new: y must be a number, got '..type(M))N=tostring(N)a5=tonumber(a5)a6=tonumber(a6)if not a5 then a5=globalTextColor end;_newHeader={text=N,hidden=false,pos={x=math.floor((globalMonitorWidth-string.len(N)+1)/2),y=M},colors={textColor=a5,backgroundTextColor=a6},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newHeader,Header)return _newHeader end;function Header:draw()if not self.hidden then self.callbacks.onDraw(self)local G=globalTextColor;local H=globalBackgroundTextColor;local a7=globalMonitor.getBackgroundColor()setTextColor(self.colors.textColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(a7)end;local R=stringSplit(self.text,'\n')self.pos.x=math.floor((globalMonitorWidth-string.len(R[1])+1)/2)text(self.pos.x,self.pos.y,R[1])table.remove(R,1)for i,j in pairs(R)do local a8=math.floor((globalMonitorWidth-string.len(j)+1)/2)local a9=self.pos.y+i;text(a8,a9,j)end;setTextColor(G)setBackgroundTextColor(H)end end;function Header:setCallback(o,p)assert(type(p)=='function','Header.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p end end;function Header:touch(L,M,o,a3)assert(type(L)=='number','Header.touch: x must be a number, got '..type(L))assert(type(M)=='number','Header.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then self.pos.x=math.floor((globalMonitorWidth-string.len(self.text)+1)/2)local U=self.pos.x+string.len(self.text)-1;if checkAreaPress(self.pos.x,self.pos.y,U,self.pos.y,L,M)then self.callbacks.onPress(self,o)return true else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function Header:hide(w)assert(type(w)=='boolean','Header.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Header.__index=Header;Label={}function Label.new(L,M,N,a5,a6)assert(type(L)=='number','Label.new: x must be a number, got '..type(L))assert(type(M)=='number','Label.new: y must be a number, got '..type(M))N=tostring(N)a5=tonumber(a5)a6=tonumber(a6)if not a5 then a5=globalTextColor end;_newLabel={text=N,hidden=false,pos={x=L,y=M},colors={textColor=a5,backgroundTextColor=a6},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newLabel,Label)return _newLabel end;function Label:draw()if not self.hidden then self.callbacks.onDraw(self)local G=globalTextColor;local H=globalBackgroundTextColor;local a7=globalMonitor.getBackgroundColor()setTextColor(self.colors.textColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(a7)end;text(self.pos.x,self.pos.y,self.text)setTextColor(G)setBackgroundTextColor(H)end end;function Label:setCallback(o,p)assert(type(p)=='function','Label.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p end end;function Label:touch(L,M,o,a3)assert(type(L)=='number','Label.touch: x must be a number, got '..type(L))assert(type(M)=='number','Label.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then local U=self.pos.x+string.len(self.text)-1;if checkAreaPress(self.pos.x,self.pos.y,U,self.pos.y,L,M)then self.callbacks.onPress(self,o)return true else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function Label:hide(w)assert(type(w)=='boolean','Label.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Label.__index=Label;Button={}function Button.new(S,T,U,V,N,a5,a6,aa,ab)assert(type(S)=='number','Button.new: x1 must be a number, got '..type(S))assert(type(T)=='number','Button.new: y1 must be a number, got '..type(T))assert(type(U)=='number','Button.new: x2 must be a number, got '..type(U))assert(type(V)=='number','Button.new: y2 must be a number, got '..type(V))N=tostring(N)a5=tonumber(a5)a6=tonumber(a6)aa=tonumber(aa)ab=tonumber(ab)if not a5 then a5=globalTextColor end;if not aa then aa=globalColor end;if not ab then ab=globalColor end;_newButton={text=N,state=false,hidden=false,pos={x1=S,y1=T,x2=U,y2=V},colors={textColor=a5,backgroundTextColor=a6,pressedButtonColor=aa,notPressedButtonColor=ab},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newButton,Button)return _newButton end;function Button:draw()if not self.hidden then self.callbacks.onDraw(self)local a4=globalRectangleType;local I=globalColor;local G=globalTextColor;local H=globalBackgroundTextColor;setRectangleType(rectangleTypes.filled)if self.state then setColor(self.colors.pressedButtonColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(self.colors.pressedButtonColor)end else setColor(self.colors.notPressedButtonColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(self.colors.notPressedButtonColor)end end;setTextColor(self.colors.textColor)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)local ac=self.pos.x1+math.floor((self.pos.x2-self.pos.x1-string.len(self.text)+1)/2)local ad=self.pos.y1+math.floor((self.pos.y2-self.pos.y1)/2)text(ac,ad,self.text)setRectangleType(a4)setColor(I)setTextColor(G)setBackgroundTextColor(H)end end;function Button:setCallback(o,p)assert(type(p)=='function','Button.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p end end;function Button:touch(L,M,o,a3)assert(type(L)=='number','Button.touch: x must be a number, got '..type(L))assert(type(M)=='number','Button.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,L,M)then self.state=not self.state;self.callbacks.onPress(self,o)return true else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function Button:hide(w)assert(type(w)=='boolean','Button.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Button.__index=Button;Menu={}function Menu.new(S,T,U,V,J)assert(type(S)=='number','Menu.new: x1 must be a number, got '..type(S))assert(type(T)=='number','Menu.new: y1 must be a number, got '..type(T))assert(type(U)=='number','Menu.new: x2 must be a number, got '..type(U))assert(type(V)=='number','Menu.new: y2 must be a number, got '..type(V))J=tonumber(J)if not J then J=globalColor end;_newMenu={color=J,objs={},hidden=true,pos={x1=S,y1=T,x2=U,y2=V},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onButtonPress=function()end,onFailedButtonPress=function()end}}setmetatable(_newMenu,Menu)return _newMenu end;function Menu:draw()if not self.hidden then self.callbacks.onDraw(self)local a4=globalRectangleType;local I=globalColor;setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)for ae=#self.objs,1,-1 do local af=self.objs[ae]af:draw()end;setColor(I)end end;function Menu:setCallback(o,p)assert(type(p)=='function','Menu.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p elseif o==4 then self.callbacks.onButtonPress=p elseif o==5 then self.callbacks.onFailedButtonPress=p end end;function Menu:set(k,ag)for i,af in pairs(k)do assert(getmetatable(af)==Button,'Menu.set: you can only attach buttons to menus.')end;local ah=math.abs(self.pos.x2-self.pos.x1)+1;local ai=math.abs(self.pos.y2-self.pos.y1)+1;for ae=ai+1,#k do table.remove(k,ai+1)end;local aj=math.floor(ai/#k)local ak=math.min(self.pos.x1,self.pos.x2)local al=math.max(self.pos.x1,self.pos.x2)local am=math.min(self.pos.y1,self.pos.y2)local an=math.max(self.pos.y1,self.pos.y2)for i,af in pairs(k)do af.pos.x1=ak;af.pos.x2=al;if ag then af.pos.y1=am+(i-1)*aj;af.pos.y2=am+(i-1)*aj+aj-1 else af.pos.y1=am+i-1;af.pos.y2=am+i-1 end;af.text=string.sub(af.text,0,ah)table.insert(self.objs,af)end end;function Menu:touch(L,M,o,a3)assert(type(L)=='number','Menu.touch: x must be a number, got '..type(L))assert(type(M)=='number','Menu.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,L,M)then self.callbacks.onPress(self,o)local ao=false;for i,af in pairs(self.objs)do if af:touch(L,M,o,ao)then self.callbacks.onButtonPress(self,af,o)ao=true else self.callbacks.onFailedButtonPress(self,af,o)end end;return ao else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function Menu:hide(w)assert(type(w)=='boolean','Menu.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Menu.__index=Menu;PercentageBar={}function PercentageBar.new(S,T,U,V,m,ap,aq,ar,as,at,au,av)assert(type(S)=='number','PercentageBar.new: x1 must be a number, got '..type(S))assert(type(T)=='number','PercentageBar.new: y1 must be a number, got '..type(T))assert(type(U)=='number','PercentageBar.new: x2 must be a number, got '..type(U))assert(type(V)=='number','PercentageBar.new: y2 must be a number, got '..type(V))assert(type(m)=='number','PercentageBar.new: value must be a number, got '..type(m))assert(type(ap)=='number','PercentageBar.new: min must be a number, got '..type(ap))assert(type(aq)=='number','PercentageBar.new: max must be a number, got '..type(aq))as=tonumber(as)at=tonumber(at)au=tonumber(au)av=tonumber(av)if not as then as=globalTextColor end;if not au then au=globalColor end;_newPercentageBar={hidden=false,value={draw=ar,drawOnPB=true,percentage=nil,current=nil,max=aq,min=ap},pos={x1=S,y1=T,x2=U,y2=V},colors={valueColor=as,backgroundValueColor=at,barColor=au,backgroundBarColor=av},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}PercentageBar.setValue(_newPercentageBar,m)setmetatable(_newPercentageBar,PercentageBar)return _newPercentageBar end;function PercentageBar:draw()if not self.hidden then self.callbacks.onDraw(self)local a4=globalRectangleType;local I=globalColor;local G=globalTextColor;local H=globalBackgroundTextColor;local a7=globalMonitor.getBackgroundColor()setRectangleType(rectangleTypes.filled)local aw=self.pos.x1+(self.pos.x2-self.pos.x1)*self.value.percentage/100;if self.colors.backgroundBarColor then setColor(self.colors.backgroundBarColor)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)if self.value.percentage>0 then setColor(self.colors.barColor)rectangle(self.pos.x1,self.pos.y1,aw,self.pos.y2)end else if self.value.percentage>0 then setColor(self.colors.barColor)rectangle(self.pos.x1,self.pos.y1,aw,self.pos.y2)end end;if self.value.draw then local ax=self.value.percentage..'%'local ay=self.pos.x1+math.floor((self.pos.x2-self.pos.x1-string.len(ax)+1)/2)local az;if self.value.drawOnPB then az=self.pos.y1+math.floor((self.pos.y2-self.pos.y1)/2)else if self.pos.y1>self.pos.y2 then az=self.pos.y1+1 else az=self.pos.y2+1 end end;setTextColor(self.colors.valueColor)if self.colors.backgroundValueColor then setBackgroundTextColor(self.colors.backgroundValueColor)text(ay,az,ax)else if self.value.drawOnPB then if self.colors.backgroundBarColor then setBackgroundTextColor(self.colors.backgroundBarColor)else setBackgroundTextColor(a7)end;if self.pos.x1<self.pos.x2 then local aA=math.floor(aw)-ay+1;if aA<0 then aA=0 elseif aA>string.len(ax)then aA=string.len(ax)end;if aA<string.len(ax)then text(ay,az,ax)end;if aA>0 then setBackgroundTextColor(self.colors.barColor)text(ay,az,string.sub(ax,1,aA))end else local aA=ay+string.len(ax)-math.ceil(aw)if aA<0 then aA=0 elseif aA>string.len(ax)then aA=string.len(ax)end;if aA<string.len(ax)then text(ay,az,ax)end;if aA>0 then setBackgroundTextColor(self.colors.barColor)text(ay+string.len(ax)-aA,az,string.sub(ax,-aA))end end else setBackgroundTextColor(a7)text(ay,az,self.value.percentage..'%')end end end;setRectangleType(a4)setColor(I)setTextColor(G)setBackgroundTextColor(H)end end;function PercentageBar:setCallback(o,p)assert(type(p)=='function','PercentageBar.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p end end;function PercentageBar:setValue(m)assert(type(m)=='number','PercentageBar.setValue: value must be a number, got '..type(m))if m<self.value.min then m=self.value.min end;if m>self.value.max then m=self.value.max end;self.value.current=m;self.value.percentage=math.floor((self.value.current-self.value.min)/(self.value.max-self.value.min)*100)end;function PercentageBar:touch(L,M,o,a3)assert(type(L)=='number','PercentageBar.touch: x must be a number, got '..type(L))assert(type(M)=='number','PercentageBar.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,L,M)then self.callbacks.onPress(self,o)return true else self.callbacks.onFailedPress(self,o)return false end else self.callbacks.onFailedPress(self,o)end end;return false end;function PercentageBar:hide(w)assert(type(w)=='boolean','PercentageBar.hide: bool must be a boolean, got '..type(w))self.hidden=w end;PercentageBar.__index=PercentageBar;Memo={}function Memo.new(S,T,U,V,a5,a6,J,aB)assert(type(S)=='number','Memo.new: x1 must be a number, got '..type(S))assert(type(T)=='number','Memo.new: y1 must be a number, got '..type(T))assert(type(U)=='number','Memo.new: x2 must be a number, got '..type(U))assert(type(V)=='number','Memo.new: y2 must be a number, got '..type(V))a5=tonumber(a5)a6=tonumber(a6)J=tonumber(J)aB=tonumber(aB)if not a5 then a5=globalTextColor end;if not J then J=globalColor end;if not a6 then a6=J end;if not aB then aB=colors.white end;_newMemo={active=false,hidden=false,selfLoop=false,lines={},pos={x1=S,y1=T,x2=U,y2=V},editSettings={editable=true,charEvent=true,keyEvent=true},cursor={text=' ',colors={textColor=a5,backgroundTextColor=aB},visible=false,blink={automatic=true,enabled=false,clock=os.clock(),speed=0.5},pos={char=1,line=1},limits={enabled=true,char=math.abs(U-S)+1,line=math.abs(V-T)+1}},colors={textColor=a5,backgroundTextColor=a6,color=J},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onEdit=function()end,onCursorBlink=function()end,onActivated=function()end,onDeactivated=function()end}}setmetatable(_newMemo,Memo)return _newMemo end;function Memo:draw()if not self.hidden then self.callbacks.onDraw(self)local a4=globalRectangleType;local I=globalColor;local G=globalTextColor;local H=globalBackgroundTextColor;local a7=globalMonitor.getBackgroundColor()local aC=math.min(self.pos.x1,self.pos.x2)local aD=math.max(self.pos.x1,self.pos.x2)local aE=math.min(self.pos.y1,self.pos.y2)local aF=math.max(self.pos.y1,self.pos.y2)setRectangleType(rectangleTypes.filled)setColor(self.colors.color)setTextColor(self.colors.textColor)setBackgroundTextColor(self.colors.backgroundTextColor)rectangle(aC,aE,aD,aF)local aG=aD-aC;local aH=aF-aE;local aI={x=self.cursor.pos.char-1,y=self.cursor.pos.line-1}if aI.x>aG then aI.x=aG elseif aI.x<0 then aI.x=0 end;if aI.y>aH then aI.y=aH elseif aI.y<0 then aI.y=0 end;for ae=0,math.abs(aF-aE)do if self.cursor.pos.line-1<=aH then if self.lines[ae+1]then if self.cursor.pos.char-1<=aG then text(aC,aE+ae,string.sub(self.lines[ae+1],1,aG+1))else text(aC,aE+ae,string.sub(self.lines[ae+1],self.cursor.pos.char-aG,self.cursor.pos.char))end end else if self.lines[ae+self.cursor.pos.line-aH]then if self.cursor.pos.char-1<=aG then text(aC,aE+ae,string.sub(self.lines[ae+self.cursor.pos.line-aH],1,aG+1))else text(aC,aE+ae,string.sub(self.lines[ae+self.cursor.pos.line-aH],self.cursor.pos.char-aG,self.cursor.pos.char))end end end end;if self.cursor.visible then setTextColor(self.cursor.colors.textColor)setBackgroundTextColor(self.cursor.colors.backgroundTextColor)text(aC+aI.x,aE+aI.y,self.cursor.text)end;setRectangleType(a4)setColor(I)setTextColor(G)setBackgroundTextColor(H)end end;function Memo:setCallback(o,p)assert(type(p)=='function','Memo.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p elseif o==4 then self.callbacks.onEdit=p elseif o==5 then self.callbacks.onCursorBlink=p elseif o==6 then self.callbacks.onActivated=p elseif o==7 then self.callbacks.onDeactivated=p end end;function Memo:setCursorLimits(aJ,aK)assert(type(aJ)=='number'or type(aJ)=='nil','Memo.setCursorLimits: char must be a number or nil, got '..type(aJ))assert(type(aK)=='number'or type(aK)=='nil','Memo.setCursorLimits: line must be a number or nil, got '..type(aK))self.cursor.limits.char=aJ;self.cursor.limits.line=aK end;function Memo:setCursorPos(aJ,aK,aL)assert(type(aJ)=='number','Memo.setCursorPos: char must be a number, got '..type(aJ))assert(type(aK)=='number','Memo.setCursorPos: line must be a number, got '..type(aK))if aJ<1 then aJ=1 end;if aK<1 then aK=1 end;if self.cursor.limits.enabled then if self.cursor.limits.char then if aJ>self.cursor.limits.char+1 then aJ=self.cursor.limits.char end end;if self.cursor.limits.line then if aK>self.cursor.limits.line then aK=self.cursor.limits.line end end end;if not self.lines[aK]then if aL then for ae=#self.lines+1,aK do table.insert(self.lines,'')end else if#self.lines>0 then aK=#self.lines else aK=1 end end end;if self.lines[aK]then if aJ>#self.lines[aK]+1 then aJ=#self.lines[aK]+1 end else aJ=1 end;self.cursor.pos.char=aJ;self.cursor.pos.line=aK end;function Memo:edit(o)if not self.editSettings.editable then return end;if not self.hidden then local function aM(event)if not event then return false end;if not self.lines[1]then self:setCursorPos(1,1,true)end;self.callbacks.onEdit(self,event)if self.cursor.limits.enabled then if self.cursor.limits.line then if#self.lines>self.cursor.limits.line then for ae=self.cursor.limits.line+1,#self.lines+1 do table.remove(self.lines,self.cursor.limits.line)end end end;for i,j in pairs(self.lines)do if self.cursor.limits.char then if#j>self.cursor.limits.char then self.lines[i]=j:sub(1,self.cursor.limits.char)end end end end;if event[1]=='monitor_touch'and(event[2]==globalMonitorName or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,event[2]))then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,event[3],event[4])then return true else return false end elseif event[1]=='mouse_click'and(globalMonitorName=='term'or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,'term'))then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,event[3],event[4])then return true else return false end elseif event[1]=='char'and self.editSettings.charEvent then local aN=self.lines[self.cursor.pos.line]if self.cursor.limits.enabled then if self.cursor.limits.char then if self.cursor.pos.char<=self.cursor.limits.char then self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)..event[2]..aN:sub(self.cursor.pos.char,#aN)self.cursor.pos.char=self.cursor.pos.char+1 end else self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)..event[2]..aN:sub(self.cursor.pos.char,#aN)self.cursor.pos.char=self.cursor.pos.char+1 end else self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)..event[2]..aN:sub(self.cursor.pos.char,#aN)self.cursor.pos.char=self.cursor.pos.char+1 end elseif event[1]=='key'and self.editSettings.keyEvent then local aN=self.lines[self.cursor.pos.line]if event[2]==28 then if self.cursor.limits.enabled then if self.cursor.limits.line then if#self.lines+1<=self.cursor.limits.line then table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aN:sub(self.cursor.pos.char,#aN)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aN:sub(self.cursor.pos.char,#aN)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aN:sub(self.cursor.pos.char,#aN)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end elseif event[2]==14 then if self.cursor.pos.char>1 then self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-2)..aN:sub(self.cursor.pos.char,#aN)self.cursor.pos.char=self.cursor.pos.char-1 elseif self.cursor.pos.line>1 then local aO=#self.lines[self.cursor.pos.line-1]if self.cursor.limits.enabled then if self.cursor.limits.char then if aO+#aN<=self.cursor.limits.char then self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aN:sub(self.cursor.pos.char,#aN)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aO+1 end else self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aN:sub(self.cursor.pos.char,#aN)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aO+1 end else self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aN:sub(self.cursor.pos.char,#aN)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aO+1 end end elseif event[2]==211 then if self.cursor.pos.char>#aN then if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.char then if#self.lines[self.cursor.pos.line+1]+#aN<=self.cursor.limits.char then self.lines[self.cursor.pos.line]=aN..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end else self.lines[self.cursor.pos.line]=aN..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end else self.lines[self.cursor.pos.line]=aN..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end end else self.lines[self.cursor.pos.line]=aN:sub(0,self.cursor.pos.char-1)..aN:sub(self.cursor.pos.char+1,#aN)end elseif event[2]==203 then if self.cursor.pos.char>1 then self.cursor.pos.char=self.cursor.pos.char-1 else if self.cursor.pos.line>1 then self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end elseif event[2]==205 then if self.cursor.pos.char<=#aN then if self.cursor.limits.enabled then if self.cursor.limits.char then if self.cursor.pos.char<=self.cursor.limits.char then self.cursor.pos.char=self.cursor.pos.char+1 end else self.cursor.pos.char=self.cursor.pos.char+1 end else self.cursor.pos.char=self.cursor.pos.char+1 end else if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.line then if self.cursor.pos.line<self.cursor.limits.line then self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end end end elseif event[2]==200 then if self.cursor.pos.line>1 then self.cursor.pos.line=self.cursor.pos.line-1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end elseif event[2]==208 then if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.line then if self.cursor.pos.line<self.cursor.limits.line then self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end else self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end else self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end end end end;return true end;if not self.selfLoop then aM(o)else self.active=true;while self.active do local aP=os.startTimer(self.cursor.blink.speed/2)o={os.pullEvent()}if not aM(o)then break end;self:draw()if self.cursor.blink.enabled then if os.clock()>=self.cursor.blink.clock+self.cursor.blink.speed then self.cursor.blink.clock=os.clock()self.callbacks.onCursorBlink(self,o)self.cursor.visible=not self.cursor.visible end end;os.cancelTimer(aP)end end end end;function Memo:touch(L,M,o,a3)assert(type(L)=='number','Memo.touch: x must be a number, got '..type(L))assert(type(M)=='number','Memo.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 and checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,L,M)then self.callbacks.onPress(self,o)self.active=true;self.callbacks.onActivated(self,o)if self.selfLoop then self.cursor.blink.enabled=true;self.cursor.visible=true;self:edit(o)self.active=false;self.callbacks.onDeactivated(self,o)self.cursor.blink.enabled=false;self.cursor.visible=false elseif self.editSettings.editable and self.cursor.blink.automatic then self.cursor.blink.enabled=true;self.cursor.visible=true end;return true else self.callbacks.onFailedPress(self,o)if self.active then self.active=false;self.callbacks.onDeactivated(self,o)if self.editSettings.editable and self.cursor.blink.automatic then self.cursor.blink.enabled=false;self.cursor.visible=false end end;return false end end;if self.active then self.active=false;self.callbacks.onDeactivated(self,o)end;return false end;function Memo:tick(o)if not self.hidden then if not self.selfLoop then if self.cursor.blink.enabled then if os.clock()>=self.cursor.blink.clock+self.cursor.blink.speed then self.cursor.blink.clock=os.clock()self.callbacks.onCursorBlink(self,o)self.cursor.visible=not self.cursor.visible end end end end end;function Memo:key(o)if not self.hidden then if not self.selfLoop then if self.active then self:edit(o)end end end end;function Memo:char(o)if not self.hidden then if not self.selfLoop then if self.active then self:edit(o)end end end end;function Memo:write(a)if not a then a=''end;a=tostring(a)if not self.lines[1]then self:setCursorPos(1,1,true)end;self.callbacks.onEdit(self,{'write',a})local R=stringSplit(a,'\n')for i,j in pairs(R)do if i~=1 then if self.lines[self.cursor.pos.line+1]then self:setCursorPos(#self.lines[self.cursor.pos.line+1],self.cursor.pos.line+1)else self:setCursorPos(1,self.cursor.pos.line+1,true)end end;local aN=self.lines[self.cursor.pos.line]aN=aN:sub(0,self.cursor.pos.char-1)..j..aN:sub(self.cursor.pos.char,#aN)self.lines[self.cursor.pos.line]=aN;self:setCursorPos(self.cursor.pos.char+#j,self.cursor.pos.line)if self.cursor.limits.enabled then if self.cursor.limits.char then if#aN>self.cursor.limits.char then aN=aN:sub(1,self.cursor.limits.char)end end end;self.lines[self.cursor.pos.line]=aN end end;function Memo:print(a)if not a then a=''end;a=tostring(a)self:write(a..'\n')end;function Memo:clear()self.cursor.pos.char=1;self.cursor.pos.line=1;self.lines={}end;function Memo:enableSelfLoop(w)assert(type(w)=='boolean','Memo.enableSelfLoop: bool must be a boolean, got '..type(w))self.selfLoop=w end;function Memo:limits(w)assert(type(w)=='boolean','Memo.limits: bool must be a boolean, got '..type(w))self.cursor.limits.enabled=w end;function Memo:editable(w)assert(type(w)=='boolean','Memo.editable: bool must be a boolean, got '..type(w))self.editSettings.editable=w end;function Memo:hide(w)assert(type(w)=='boolean','Memo.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Memo.__index=Memo;Window={}function Window.new(S,T,U,V,J)assert(type(S)=='number','Window.new: x1 must be a number, got '..type(S))assert(type(T)=='number','Window.new: y1 must be a number, got '..type(T))assert(type(U)=='number','Window.new: x2 must be a number, got '..type(U))assert(type(V)=='number','Window.new: y2 must be a number, got '..type(V))J=tonumber(J)if not J then J=term.getBackgroundColor()end;_newWindow={active=false,hidden=false,color=J,grabbedFrom={x=1,y=1},shadow={enabled=false,color=colors.black,offset={x=1,y=1}},objs={list={},events={draw={},touch={},tick={},key={},char={},mouse_drag={}}},pos={x1=S,y1=T,x2=U,y2=V},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onOBJPress=function()end,onFailedOBJPress=function()end,onEvent=function()end}}setmetatable(_newWindow,Window)return _newWindow end;function Window:draw()if not self.hidden then self.callbacks.onDraw(self)local a4=globalRectangleType;local I=globalColor;setRectangleType(rectangleTypes.filled)if self.shadow.enabled then setColor(self.shadow.color)local aQ=self.shadow.offset.x;local aR=self.shadow.offset.y;local aS=self.pos.x1+aQ;local aT=self.pos.x2+aQ;local aU=self.pos.y1+aR;local aV=self.pos.y2+aR;rectangle(aS,aU,aT,aV)end;setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)setRectangleType(a4)setColor(I)for s,af in pairs(self.objs.events.draw)do af:draw()end end end;function Window:setCallback(o,p)assert(type(p)=='function','Window.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onPress=p elseif o==3 then self.callbacks.onFailedPress=p elseif o==4 then self.callbacks.onOBJPress=p elseif o==5 then self.callbacks.onFailedOBJPress=p elseif o==6 then self.callbacks.onEvent=p end end;function Window:set(aW)assert(type(aW)=='table','Window.set: objGroup must be a table, got '..type(aW))self.objs.list=aW;self.objs.events=getOBJSEvents(aW)end;function Window:touch(L,M,o,a3)assert(type(L)=='number','Window.touch: x must be a number, got '..type(L))assert(type(M)=='number','Window.touch: y must be a number, got '..type(M))if not self.hidden then self.callbacks.onEvent(self,o)if not a3 then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,L,M)then self.active=true;self.grabbedFrom.x=L;self.grabbedFrom.y=M;self.callbacks.onPress(self,o)local ao=false;for s,af in pairs(self.objs.events.touch)do if af:touch(L,M,o,ao)then self.callbacks.onOBJPress(self,af,o)ao=true else self.callbacks.onFailedOBJPress(self,af,o)end end;return true else self.active=false;self.callbacks.onFailedPress(self,o)return false end else self.active=false;self.callbacks.onFailedPress(self,o)end end;return false end;function Window:mouse_drag(o)if not self.hidden then self.callbacks.onEvent(self,o)if self.active then local aX=o[3]-self.grabbedFrom.x;local aY=o[4]-self.grabbedFrom.y;self.grabbedFrom.x=o[3]self.grabbedFrom.y=o[4]self.pos.x1=self.pos.x1+aX;self.pos.x2=self.pos.x2+aX;self.pos.y1=self.pos.y1+aY;self.pos.y2=self.pos.y2+aY;for s,af in pairs(self.objs.list)do if af.pos.x then af.pos.x=af.pos.x+aX end;if af.pos.x1 then af.pos.x1=af.pos.x1+aX end;if af.pos.x2 then af.pos.x2=af.pos.x2+aX end;if af.pos.y then af.pos.y=af.pos.y+aY end;if af.pos.y1 then af.pos.y1=af.pos.y1+aY end;if af.pos.y2 then af.pos.y2=af.pos.y2+aY end end end end end;function Window:tick(o)if not self.hidden then self.callbacks.onEvent(self,o)for i,af in pairs(self.objs.events.tick)do af:tick(o)end end end;function Window:key(o)if not self.hidden then self.callbacks.onEvent(self,o)for i,af in pairs(self.objs.events.key)do af:key(o)end end end;function Window:char(o)if not self.hidden then self.callbacks.onEvent(self,o)for i,af in pairs(self.objs.events.char)do af:char(o)end end end;function Window:hide(w)assert(type(w)=='boolean','Window.hide: bool must be a boolean, got '..type(w))self.hidden=w end;Window.__index=Window;OBJGroup={}function OBJGroup.new()_newOBJGroup={objs={list={},events={draw={},touch={},tick={},key={},char={},mouse_drag={}}},hidden=false,callbacks={onDraw=function()end,onOBJPress=function()end,onFailedOBJPress=function()end}}setmetatable(_newOBJGroup,OBJGroup)return _newOBJGroup end;function OBJGroup:draw()if not self.hidden then self.callbacks.onDraw(self)for s,af in pairs(self.objs.events.draw)do af:draw()end end end;function OBJGroup:setCallback(o,p)assert(type(p)=='function','OBJGroup.setCallback: callback must be a function, got '..type(p))if o==1 then self.callbacks.onDraw=p elseif o==2 then self.callbacks.onOBJPress=p elseif o==3 then self.callbacks.onFailedOBJPress=p end end;function OBJGroup:set(aW)assert(type(aW)=='table','OBJGroup.set: objGroup must be a table, got '..type(aW))self.objs.list=aW;self.objs.events=getOBJSEvents(aW)end;function OBJGroup:touch(L,M,o,a3)assert(type(L)=='number','OBJGroup.touch: x must be a number, got '..type(L))assert(type(M)=='number','OBJGroup.touch: y must be a number, got '..type(M))if not self.hidden then if not a3 then local ao=false;for s,af in pairs(self.objs.list)do if af:touch(L,M,o,ao)then self.callbacks.onOBJPress(self,af,o)ao=true else self.callbacks.onFailedOBJPress(self,af,o)end end;return ao end end;return false end;function OBJGroup:tick(o)if not self.hidden then for i,af in pairs(self.objs.events.tick)do af:tick(o)end end end;function OBJGroup:key(o)if not self.hidden then for i,af in pairs(self.objs.events.key)do af:key(o)end end end;function OBJGroup:char(o)if not self.hidden then for i,af in pairs(self.objs.events.char)do af:char(o)end end end;function OBJGroup:mouse_drag(o)if not self.hidden then for i,af in pairs(self.objs.events.mouse_drag)do af:mouse_drag(o)end end end;function OBJGroup:hide(w)assert(type(w)=='boolean','OBJGroup.hide: bool must be a boolean, got '..type(w))self.hidden=w end;OBJGroup.__index=OBJGroup;globalLoop.stats.FPS=Label.new(0,0,'0FPS')globalLoop.stats.EPS=Label.new(0,0,'0EPS')globalLoop.stats.FPS.hidden=true;globalLoop.stats.EPS.hidden=true;table.insert(globalLoop.group.LIBPrivate.objs,globalLoop.stats.FPS)table.insert(globalLoop.group.LIBPrivate.objs,globalLoop.stats.EPS)function drawOnLoopClock()globalLoop.drawOnClock=true end;function drawOnLoopEvent()globalLoop.drawOnClock=false end;function drawLoopStats(w)assert(type(w)=='boolean','enableLoopStats: bool must be a boolean, got '..type(w))if w and globalLoop.stats.automaticPos then local aZ=globalLoop.stats.automaticPosOffset.x;local a_=globalLoop.stats.automaticPosOffset.y;globalLoop.stats.FPS.pos.x=globalMonitorWidth-#globalLoop.stats.FPS.text+1+aZ;globalLoop.stats.FPS.pos.y=globalMonitorHeight-1+a_;globalLoop.stats.EPS.pos.x=globalMonitorWidth-#globalLoop.stats.EPS.text+1+aZ;globalLoop.stats.EPS.pos.y=globalMonitorHeight+a_ end;globalLoop.stats.FPS.hidden=not w;globalLoop.stats.EPS.hidden=not w end;function setLoopClockSpeed(b0)assert(type(b0)=='number','setLoopClockSpeed: sec must be a number, got '..type(b0))globalLoop.clockSpeed=b0 end;function setLoopTimerSpeed(b0)assert(type(b0)=='number','setLoopTimerSpeed: sec must be a number, got '..type(b0))globalLoop.timerSpeed=b0 end;function setLoopCallback(o,p)assert(type(p)=='function','setLoopCallback: callback must be a function, got '..type(p))if o==1 then globalLoop.callbacks.onInit=p elseif o==2 then globalLoop.callbacks.onClock=p elseif o==3 then globalLoop.callbacks.onEvent=p elseif o==4 then globalLoop.callbacks.onTimer=p elseif o==5 then globalLoop.callbacks.onMonitorChange=p end end;function loopAutoClear(w)assert(type(w)=='boolean','loopAutoClear: bool must be a boolean, got '..type(w))globalLoop.autoClear=w end;function addLoopGroup(b1,b2)b1=tostring(b1)assert(b1~='LIBPrivate'or b1~='none',"addLoopGroup: can't overwrite Lib's Private groups")assert(type(b2)=='table','addLoopGroup: group must be a table, got '..type(b2))globalLoop.group[b1]={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs=b2}end;function removeLoopGroup(b1)b1=tostring(b1)assert(b1~='LIBPrivate'or b1~='none',"removeLoopGroup: can't remove Lib's Private groups")globalLoop.group[b1]=nil end;function setLoopGroup(b1)b1=tostring(b1)assert(globalLoop.group[b1],'setLoopGroup: groupName must be a valid group.')local b3=globalLoop.group[globalLoop.selectedGroup]local b4=globalLoop.group[b1]b3.callbacks.onUnset(b3,b4)globalLoop.selectedGroup=b1;b4.callbacks.onSet(b4,b3)globalLoop.wasGroupChanged=true end;function setLoopGroupCallback(b1,o,p)b1=tostring(b1)assert(b1~='LIBPrivate'or b1~='none',"setLoopGroupCallback: can't overwrite Lib's Private groups' callbacks")assert(globalLoop.group[b1],'setLoopGroupCallback: groupName must be a valid group.')assert(type(p)=='function','setLoopGroupCallback: callback must be a function, got '..type(p))if o==1 then globalLoop.group[b1].callbacks.onClock=p elseif o==2 then globalLoop.group[b1].callbacks.onEvent=p elseif o==3 then globalLoop.group[b1].callbacks.onTimer=p elseif o==4 then globalLoop.group[b1].callbacks.onMonitorChange=p elseif o==5 then globalLoop.group[b1].callbacks.onSet=p elseif o==6 then globalLoop.group[b1].callbacks.onUnset=p end end;function resetLoopSettings()globalLoop.APLWDBroadcastOnClock=false;globalLoop.APLWDClearCacheOnDraw=true;globalLoop.stats.FPS.hidden=true;globalLoop.stats.EPS.hidden=true;globalLoop.callbacks.onInit=function()end;globalLoop.callbacks.onEvent=function()end;globalLoop.callbacks.onClock=function()end;globalLoop.selectedGroup='none'globalLoop.group={none={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}},LIBPrivate={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}}}globalLoop.events={draw={},touch={},tick={},key={},char={},mouse_drag={}}end;function stopLoop()globalLoop.enabled=false;globalLoop.events={draw={},touch={},tick={},key={},char={},mouse_drag={}}end;function loop()globalLoop.enabled=true;if globalLoop.autoClear then bClearMonitorGroup()end;updateLoopEvents()globalLoop.callbacks.onInit()drawLoopOBJs()local b5=Clock.new(1)b5.FPS=0;b5.EPS=0;b5:setCallback(event.clock.onClock,function(self,event)globalLoop.stats.FPS.text=tostring(self.FPS)..'FPS'globalLoop.stats.EPS.text=tostring(self.EPS)..'EPS'if globalLoop.stats.automaticPos then local aZ=globalLoop.stats.automaticPosOffset.x;local a_=globalLoop.stats.automaticPosOffset.y;globalLoop.stats.FPS.pos.x=globalMonitorWidth-#globalLoop.stats.FPS.text+1+aZ;globalLoop.stats.FPS.pos.y=globalMonitorHeight-1+a_;globalLoop.stats.EPS.pos.x=globalMonitorWidth-#globalLoop.stats.EPS.text+1+aZ;globalLoop.stats.EPS.pos.y=globalMonitorHeight+a_ end;self.FPS=0;self.EPS=0 end)local b6=os.clock()while globalLoop.enabled do if globalLoop.wasGroupChanged then updateLoopEvents()globalLoop.wasGroupChanged=false end;local aP=os.startTimer(globalLoop.timerSpeed)local event={os.pullEvent()}if event[1]=='monitor_touch'and(event[2]==globalMonitorName or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,event[2]))then touchLoopOBJs(event[3],event[4],event)elseif event[1]=='mouse_click'and(globalMonitorName=='term'or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,'term'))then touchLoopOBJs(event[3],event[4],event)elseif event[1]=='key'then for s,af in pairs(globalLoop.events.key)do af:key(event)end elseif event[1]=='char'then for s,af in pairs(globalLoop.events.char)do af:char(event)end elseif event[1]=='mouse_drag'then for s,af in pairs(globalLoop.events.mouse_drag)do af:mouse_drag(event)end elseif event[1]=='timer'then globalLoop.callbacks.onTimer(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onTimer(event)end;globalLoop.clock=os.clock()if globalLoop.clock>=b6+globalLoop.clockSpeed then b6=os.clock()if globalLoop.drawOnClock then if APLWD.enabled and globalLoop.APLWDClearCacheOnDraw then APLWD.clearCache()end;if globalLoop.autoClear then bClearMonitorGroup()end;globalLoop.callbacks.onClock(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onClock(event)drawLoopOBJs()b5.FPS=b5.FPS+1 else globalLoop.callbacks.onClock(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onClock(event)end;if APLWD.enabled and globalLoop.APLWDBroadcastOnClock then APLWD.broadcastCache()end end;if not globalLoop.drawOnClock then if APLWD.enabled and globalLoop.APLWDClearCacheOnDraw then APLWD.clearCache()end;if globalLoop.autoClear then bClearMonitorGroup()end;globalLoop.callbacks.onEvent(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onEvent(event)drawLoopOBJs()b5.FPS=b5.FPS+1 else globalLoop.callbacks.onEvent(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onEvent(event)end;for s,af in pairs(globalLoop.events.tick)do af:tick(event)end;b5:tick()b5.EPS=b5.EPS+1;os.cancelTimer(aP)end end;function getOBJSEvents(k)assert(type(k)=='table','getOBJSEvents: table must be a table, got '..type(k))local b7={draw={},touch={},tick={},key={},char={},mouse_drag={}}for s,af in pairs(k)do if af.draw then table.insert(b7.draw,1,af)end;if af.touch then table.insert(b7.touch,af)end;if af.tick then table.insert(b7.tick,af)end;if af.key then table.insert(b7.key,af)end;if af.char then table.insert(b7.char,af)end;if af.mouse_drag then table.insert(b7.mouse_drag,af)end end;return b7 end;function updateLoopEvents()local b8={}for s,af in pairs(globalLoop.group.LIBPrivate.objs)do table.insert(b8,af)end;for s,af in pairs(globalLoop.group[globalLoop.selectedGroup].objs)do table.insert(b8,af)end;globalLoop.events=getOBJSEvents(b8)end;function drawLoopOBJs()if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)for i,af in pairs(globalLoop.events.draw)do af:draw()end;local q=APLWD.cacheWritable;if APLWD.enabled and q then APLWD.cacheWritable=false end;local r=globalMonitorName;for s,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=r then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)for i,af in pairs(globalLoop.events.draw)do af:draw()end end end;setMonitor(r)if APLWD.enabled and q then APLWD.cacheWritable=true end else for i,af in pairs(globalLoop.events.draw)do af:draw()end end end;function touchLoopOBJs(L,M,o)assert(type(L)=='number','touchLoopOBJs: x must be a number, got '..type(L))assert(type(M)=='number','touchLoopOBJs: y must be a number, got '..type(M))local b9=false;for s,af in pairs(globalLoop.events.touch)do if af:touch(L,M,o,b9)then b9=true end end end;local ba={...}if table.maxn(ba)>0 then ba[1]=string.lower(ba[1])if ba[1]=='ver'then print('Lib version: '..ver)elseif ba[1]=='setup'then if shell then local bb='/'..shell.getRunningProgram()OSSettings.set('APLibPath',bb)print('Setup completed!\nAPLibPath: '..tostring(settings.get('APLibPath')))sleep(2)os.reboot()else error('Setup failed, shell API not available!')end elseif ba[1]=='create'then if ba[2]then local N='\n-- //AUTO-GENERATED-CODE//\nlocal APLibPath = settings.get(\'APLibPath\')\n\nassert(  -- check if setup was done before, if not return with an error\n    type(APLibPath) == \'string\',\n    \'Couldn\\\'t open APLib through path: \'..tostring(\n        APLibPath\n    )..\'; probably you haven\\\'t completed Lib setup via \\\'LIBFILE setup\\\' or the setup failed\'\n)\n\nassert( -- check if Lib is still there, if not return with an error\n    fs.exists(APLibPath),\n    \'Couldn\\\'t open APLib through path: \'..tostring(\n      	APLibPath\n    )..\'; remember that if you move the Lib\\\'s folder you must set it up again via \\\'LIBFILE setup\\\'\'\n)\n\nos.loadAPI(APLibPath) -- load Lib with CraftOS\'s built-in feature\n\nAPLibPath = fs.getName(APLibPath)\nif APLibPath:sub(#APLibPath - 3) == \'.lua\' then APLibPath = APLibPath:sub(1, #APLibPath - 4); end\nlocal APLib = _ENV[APLibPath]\nAPLibPath = nil\n-- //--//\n\n'local bc='/'..ba[2]if fs.exists(bc)then print('Are you sure you want to overwrite: '..bc)print('Press ENTER to confirm or another key to cancel.')local event={os.pullEvent('key')}if event[2]==28 then local bd=fs.open(bc,'w')if bd then bd.write(N)bd.close()print('File succesfully created!')else print('Couldn\'t create file.')end else print('File wasn\'t created!')end else local bd=fs.open(bc,'w')if bd then bd.write(N)bd.close()print('File succesfully created!')else print('Couldn\'t create file.')end end else print('You must specify the name of the file you want to create.')end end end