info={ver='1.20.0',author='hds536jhmk',website='https://github.com/hds536jhmk/APLib'}globalMonitor=term;globalMonitorName='term'globalMonitorGroup={enabled=false,list={}}globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()globalColor=colors.white;globalTextColor=colors.white;globalBackgroundTextColor=colors.black;globalRectangleType=1;globalLoop={enabled=false,autoClear=true,drawOnClock=true,clockSpeed=0.5,timerSpeed=0.1,clock=0,APLWDBroadcastOnClock=false,APLWDClearCacheOnDraw=true,stats={automaticPos=true,automaticPosOffset={x=0,y=0}},callbacks={onInit=function()end,onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end},events={draw={},touch={},tick={},key={},char={},mouse_drag={}},wasGroupChanged=false,selectedGroup='none',group={none={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}},LIBPrivate={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}}}}globalCallbacks={onBClear=function()end,onSetMonitor=function()end}rectangleTypes={filled=1,hollow=2,checker=3}event={global={onBClear=1,onSetMonitor=2},clock={onClock=1},point={onDraw=1,onPress=2,onFailedPress=3},rectangle={onDraw=1,onPress=2,onFailedPress=3},header={onDraw=1,onPress=2,onFailedPress=3},label={onDraw=1,onPress=2,onFailedPress=3},button={onDraw=1,onPress=2,onFailedPress=3},menu={onDraw=1,onPress=2,onFailedPress=3,onButtonPress=4,onFailedButtonPress=5},percentagebar={onDraw=1,onPress=2,onFailedPress=3},memo={onDraw=1,onPress=2,onFailedPress=3,onEdit=4,onCursorBlink=5,onActivated=6,onDeactivated=7},window={onDraw=1,onPress=2,onFailedPress=3,onOBJPress=4,onFailedOBJPress=5,onEvent=6},objGroup={onDraw=1,onOBJPress=2,onFailedOBJPress=3},loop={group={onClock=1,onEvent=2,onTimer=3,onMonitorChange=4,onSet=5,onUnset=6},onInit=1,onClock=2,onEvent=3,onTimer=4,onMonitorChange=5}}function stringSplit(a,b)a=tostring(a)b=tostring(b)local c={}while true do local d=a:find(b)if d then table.insert(c,a:sub(1,d-1))a=a:sub(d+1)else table.insert(c,a)break end end;return c end;function tableHasKey(e,f)assert(type(e)=='table','tableHasKey: table must be a table, got '..type(e))assert(type(f)=='string'or type(f)=='number','tableHasKey: key must be a string or a number, got '..type(f))for g,h in pairs(e)do if g==f then return true,h end end;return false end;function tableHasValue(e,i)assert(type(e)=='table','tableHasValue: table must be a table, got '..type(e))for g,h in pairs(e)do if h==i then return true,g end end;return false end;OSSettings={settingsPath='/.settings',set=function(j,i)assert(type(i)~='nil',"OSSettings.set: value can't be nil, got "..type(i))settings.set(tostring(j),i)return settings.save(OSSettings.settingsPath)end,get=function(j)return settings.get(tostring(j))end,getNames=function()return settings.getNames()end,unset=function(j)settings.unset(tostring(j))return settings.save(OSSettings.settingsPath)end}function setGlobalCallback(k,l)assert(type(l)=='function','setGlobalCallback: callback must be a function, got '..type(l))if k==1 then globalCallbacks.onBClear=l elseif k==2 then globalCallbacks.onSetMonitor=l end end;function bClear()globalMonitor.clear()globalMonitor.setCursorPos(1,1)globalCallbacks.onBClear()if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='bClear'})end end;function bClearMonitorGroup()if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)bClear()local m=APLWD.cacheWritable;if APLWD.enabled and m then APLWD.cacheWritable=false end;local n=globalMonitorName;for o,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=n then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)bClear()end end;setMonitor(n)if APLWD.enabled and m then APLWD.cacheWritable=true end else bClear()end end;function setMonitor(p)p=tostring(p)globalCallbacks.onSetMonitor(globalMonitor,globalMonitorName,globalMonitorWidth,globalMonitorHeight)if p=='term'then globalMonitor=term;globalMonitorName='term'globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()else assert(tostring(peripheral.getType(p))=='monitor','setMonitor: monitorName must be a monitor, got '..tostring(peripheral.getType(p)))local q=peripheral.wrap(p)globalMonitor=q;globalMonitorName=p;globalMonitorWidth,globalMonitorHeight=globalMonitor.getSize()end end;function getMonitorSize()return globalMonitorWidth,globalMonitorHeight end;function setMonitorGroup(r)assert(type(r)=='table','setMonitorGroup: monitorNameList must be a table, got '..type(r))for g,h in pairs(r)do h=tostring(h)if not h=='term'then assert(tostring(peripheral.getType(h))=='monitor','setMonitorGroup: '..h..' must be a monitor, got '..tostring(peripheral.getType(h)))end end;globalMonitorGroup.list=r end;function setMonitorGroupEnabled(s)assert(type(s)=='boolean','setMonitorGroupEnabled: bool must be a boolean, got '..type(s))globalMonitorGroup.enabled=s end;function resetMonitorGroup()globalMonitorGroup.list={}end;APLWD={enabled=false,cacheWritable=true,clearOnDraw=false,protocol='APLWD-'..info.ver,senderName='SendeR',receiverName='ReceiveR',isReceiver=true,myName='',senderID='',modemName='',cache={}}APLWD.enable=function(s)assert(type(s)=='boolean','APLWD.enable: bool must be a boolean, got '..type(s))APLWD.enabled=s end;APLWD.broadcastOnLoopClock=function()globalLoop.APLWDBroadcastOnClock=true end;APLWD.dontBroadcastOnLoopClock=function()globalLoop.APLWDBroadcastOnClock=false end;APLWD.enableClearCacheOnLoopDraw=function(s)assert(type(s)=='boolean','APLWD.enableClearCacheOnLoopDraw: bool must be a boolean, got '..type(s))globalLoop.APLWDClearCacheOnDraw=s end;APLWD.host=function(t,u)if APLWD.enabled then t=tostring(t)if u then u=tostring(u)else u=tostring(os.getComputerID())end;assert(tostring(peripheral.getType(t))=='modem','APLWD.host: modemName must be a modem, got '..tostring(peripheral.getType(t)))rednet.open(t)if rednet.lookup(APLWD.protocol,APLWD.senderName..u)then rednet.close(t)error("APLWD.host: There's already someone connected with hostname: "..u)end;rednet.host(APLWD.protocol,APLWD.senderName..u)APLWD.isReceiver=false;APLWD.myName=APLWD.senderName..u;APLWD.modemName=t end end;APLWD.connect=function(t,v,u)if APLWD.enabled then t=tostring(t)if u then u=tostring(u)else u=tostring(os.getComputerID())end;v=tostring(v)assert(tostring(peripheral.getType(t))=='modem','APLWD.connect: modemName must be a modem, got '..tostring(peripheral.getType(t)))rednet.open(t)if rednet.lookup(APLWD.protocol,APLWD.receiverName..u)then rednet.close(t)error("APLWD.connect: There's already someone connected with hostname: "..u)end;local w=rednet.lookup(APLWD.protocol,APLWD.senderName..v)if not w then rednet.close(t)error("APLWD.connect: Didn't find any sender with name: "..v)end;rednet.host(APLWD.protocol,APLWD.receiverName..u)APLWD.isReceiver=true;APLWD.myName=APLWD.receiverName..u;APLWD.senderID=w;APLWD.modemName=t end end;APLWD.close=function()if APLWD.modemName~=''then if not APLWD.isReceiver then rednet.broadcast('disconnected',APLWD.protocol)end;rednet.unhost(APLWD.protocol,APLWD.myName)rednet.close(APLWD.modemName)APLWD.enable(false)APLWD.clearCache()APLWD.isReceiver=true;APLWD.myName=''APLWD.senderID=''APLWD.modemName=''end end;APLWD.broadcastCache=function()if APLWD.enabled then local x=rednet.isOpen()assert(x,'APLWD.broadcastCache: rednet connection must be opened first, connection '..tostring(x))rednet.broadcast(APLWD.cache,APLWD.protocol)APLWD.clearCache()end end;APLWD.receiveCache=function(y)if APLWD.enabled then local x=rednet.isOpen()assert(x,'APLWD.receiveCache: rednet connection must be opened first, connection '..tostring(x))local w,z,A=rednet.receive(APLWD.protocol,tonumber(y))if type(z)=='table'then if w==APLWD.senderID then APLWD.cache=z;return true end elseif z=='disconnected'then APLWD.close()return false,'disconnected'end;return false end end;APLWD.drawCache=function()if APLWD.enabled then local function B()for g,h in pairs(APLWD.cache)do if h.type=='bClear'then bClearMonitorGroup()elseif h.type=='background'then setBackgroundMonitorGroup(h.color)elseif h.type=='text'then local C=globalTextColor;local D=globalBackgroundTextColor;setTextColor(h.colors.textColor)setBackgroundTextColor(h.colors.backgroundTextColor)text(h.pos.x,h.pos.y,h.text)setTextColor(C)setBackgroundTextColor(D)elseif h.type=='point'then local E=globalColor;setColor(h.color)point(h.pos.x,h.pos.y)setColor(E)elseif h.type=='rectangle'then local E=globalColor;setColor(h.color)rectangle(h.pos.x1,h.pos.y1,h.pos.x2,h.pos.y2)setColor(E)end end end;if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)if APLWD.clearOnDraw then bClear()end;B()local n=globalMonitorName;for o,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=n then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)if APLWD.clearOnDraw then bClear()end;B()end end;setMonitor(n)else if APLWD.clearOnDraw then bClear()end;B()end;APLWD.clearCache()end end;APLWD.clearCache=function()APLWD.cache={}end;function setColor(F)assert(type(F)=='number','setColor: color must be a number, got '..type(F))globalColor=F end;function setTextColor(F)assert(type(F)=='number','setTextColor: color must be a number, got '..type(F))globalTextColor=F end;function setBackgroundTextColor(F)assert(type(F)=='number','setBackgroundTextColor: color must be a number, got '..type(F))globalBackgroundTextColor=F end;function setBackground(F)assert(type(F)=='number','setBackgroundColor: color must be a number, got '..type(F))globalMonitor.setBackgroundColor(F)local m=APLWD.cacheWritable;if APLWD.enabled and m then APLWD.cacheWritable=false end;bClear()if APLWD.enabled and m then APLWD.cacheWritable=true end;if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='background',color=F})end end;function setBackgroundMonitorGroup(F)assert(type(F)=='number','setBackgroundMonitorGroup: color must be a number, got '..type(F))if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)setBackground(F)local m=APLWD.cacheWritable;if APLWD.enabled and m then APLWD.cacheWritable=false end;local n=globalMonitorName;for o,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=n then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)setBackground(F)end end;setMonitor(n)if APLWD.enabled and m then APLWD.cacheWritable=true end else setBackground(F)end end;function setRectangleType(G)assert(type(G)=='number','setRectangleType: type must be a number, got '..type(G))globalRectangleType=G end;function text(H,I,J)assert(type(H)=='number','Text: x must be a number, got '..type(H))assert(type(I)=='number','Text: y must be a number, got '..type(I))J=tostring(J)local K,L=globalMonitor.getCursorPos()local C=globalMonitor.getTextColor()local M=globalMonitor.getBackgroundColor()globalMonitor.setTextColor(globalTextColor)globalMonitor.setBackgroundColor(globalBackgroundTextColor)local N=stringSplit(J,'\n')for g,h in pairs(N)do globalMonitor.setCursorPos(H,I+g-1)globalMonitor.write(h)end;globalMonitor.setCursorPos(K,L)globalMonitor.setTextColor(C)globalMonitor.setBackgroundColor(M)if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='text',text=J,pos={x=H,y=I},colors={textColor=globalTextColor,backgroundTextColor=globalBackgroundTextColor}})end end;function point(H,I)assert(type(H)=='number','Point: x must be a number, got '..type(H))assert(type(I)=='number','Point: y must be a number, got '..type(I))local K,L=globalMonitor.getCursorPos()globalMonitor.setCursorPos(H,I)local M=globalMonitor.getBackgroundColor()globalMonitor.setBackgroundColor(globalColor)globalMonitor.write(' ')globalMonitor.setCursorPos(K,L)globalMonitor.setBackgroundColor(M)if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='point',pos={x=H,y=I},color=globalColor})end end;function rectangle(O,P,Q,R)assert(type(O)=='number','Point: x1 must be a number, got '..type(O))assert(type(P)=='number','Point: y1 must be a number, got '..type(P))assert(type(Q)=='number','Point: x2 must be a number, got '..type(Q))assert(type(R)=='number','Point: y2 must be a number, got '..type(R))local S=1;local T=1;if O>Q then S=-1 end;if P>R then T=-1 end;local m=APLWD.cacheWritable;if APLWD.enabled and m then APLWD.cacheWritable=false end;if globalRectangleType==1 then for U=O,Q,S do for V=P,R,T do point(U,V)end end elseif globalRectangleType==2 then for U=O,Q,S do point(U,P)point(U,R)end;for V=P,R,T do point(O,V)point(Q,V)end elseif globalRectangleType==3 then local W=true;for U=O,Q,S do for V=P,R,T do if W then point(U,V)end;W=not W end;if math.abs(O-Q)%2~=0 then W=not W end end end;if APLWD.enabled and m then APLWD.cacheWritable=true end;if not APLWD.isReceiver and APLWD.cacheWritable then table.insert(APLWD.cache,{type='rectangle',pos={x1=O,y1=P,x2=Q,y2=R},color=globalColor})end end;function checkAreaPress(O,P,Q,R,X,Y)assert(type(O)=='number','checkAreaPress: x1 must be a number, got '..type(O))assert(type(P)=='number','checkAreaPress: y1 must be a number, got '..type(P))assert(type(Q)=='number','checkAreaPress: x2 must be a number, got '..type(Q))assert(type(R)=='number','checkAreaPress: y2 must be a number, got '..type(R))assert(type(X)=='number','checkAreaPress: xPressed must be a number, got '..type(X))assert(type(Y)=='number','checkAreaPress: yPressed must be a number, got '..type(Y))if O<Q then if not(X>=O and X<=Q)then return false end else if not(X<=O and X>=Q)then return false end end;if P<R then if not(Y>=P and Y<=R)then return false end else if not(Y<=P and Y>=R)then return false end end;return true end;Clock={}function Clock.new(Z)assert(type(Z)=='number','Clock.new: interval must be a number, got '..type(Z))_newClock={clock=os.clock(),interval=Z,callbacks={onClock=function()end}}setmetatable(_newClock,Clock)return _newClock end;function Clock:setCallback(k,l)assert(type(l)=='function','Clock.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onClock=l end end;function Clock:tick(k)if os.clock()>=self.clock+self.interval then self.clock=os.clock()self.callbacks.onClock(self,k)return true end;return false end;Clock.__index=Clock;Point={}function Point.new(H,I,F)assert(type(H)=='number','Point.new: x must be a number, got '..type(H))assert(type(I)=='number','Point.new: y must be a number, got '..type(I))F=tonumber(F)if not F then F=globalColor end;_newPoint={color=F,hidden=false,pos={x=H,y=I},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newPoint,Point)return _newPoint end;function Point:draw()if not self.hidden then self.callbacks.onDraw(self)local E=globalColor;setColor(self.color)point(self.pos.x,self.pos.y)setColor(E)end end;function Point:setCallback(k,l)assert(type(l)=='function','Point.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l end end;function Point:touch(H,I,k,_)assert(type(H)=='number','Point.touch: x must be a number, got '..type(H))assert(type(I)=='number','Point.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then if self.pos.x==H and self.pos.y==I then self.callbacks.onPress(self,k)return true else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function Point:hide(s)assert(type(s)=='boolean','Point.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Point.__index=Point;Rectangle={}function Rectangle.new(O,P,Q,R,F,G)assert(type(O)=='number','Rectangle.new: x1 must be a number, got '..type(O))assert(type(P)=='number','Rectangle.new: y1 must be a number, got '..type(P))assert(type(Q)=='number','Rectangle.new: x2 must be a number, got '..type(Q))assert(type(R)=='number','Rectangle.new: y2 must be a number, got '..type(R))F=tonumber(F)G=tonumber(G)if not F then F=globalColor end;if not G then G=globalRectangleType end;_newRectangle={color=F,type=G,hidden=false,pos={x1=O,y1=P,x2=Q,y2=R},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newRectangle,Rectangle)return _newRectangle end;function Rectangle:draw()if not self.hidden then self.callbacks.onDraw(self)local a0=globalRectangleType;local E=globalColor;setRectangleType(self.type)setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)setRectangleType(a0)setColor(E)end end;function Rectangle:setCallback(k,l)assert(type(l)=='function','Rectangle.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l end end;function Rectangle:touch(H,I,k,_)assert(type(H)=='number','Rectangle.touch: x must be a number, got '..type(H))assert(type(I)=='number','Rectangle.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,H,I)then self.callbacks.onPress(self,k)return true else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function Rectangle:hide(s)assert(type(s)=='boolean','Rectangle.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Rectangle.__index=Rectangle;Header={}function Header.new(I,J,a1,a2)assert(type(I)=='number','Header.new: y must be a number, got '..type(I))J=tostring(J)a1=tonumber(a1)a2=tonumber(a2)if not a1 then a1=globalTextColor end;_newHeader={text=J,hidden=false,pos={x=math.floor((globalMonitorWidth-string.len(J)+1)/2),y=I},colors={textColor=a1,backgroundTextColor=a2},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newHeader,Header)return _newHeader end;function Header:draw()if not self.hidden then self.callbacks.onDraw(self)local C=globalTextColor;local D=globalBackgroundTextColor;local a3=globalMonitor.getBackgroundColor()setTextColor(self.colors.textColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(a3)end;local N=stringSplit(self.text,'\n')self.pos.x=math.floor((globalMonitorWidth-string.len(N[1])+1)/2)text(self.pos.x,self.pos.y,N[1])table.remove(N,1)for g,h in pairs(N)do local a4=math.floor((globalMonitorWidth-string.len(h)+1)/2)local a5=self.pos.y+g;text(a4,a5,h)end;setTextColor(C)setBackgroundTextColor(D)end end;function Header:setCallback(k,l)assert(type(l)=='function','Header.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l end end;function Header:touch(H,I,k,_)assert(type(H)=='number','Header.touch: x must be a number, got '..type(H))assert(type(I)=='number','Header.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then self.pos.x=math.floor((globalMonitorWidth-string.len(self.text)+1)/2)local Q=self.pos.x+string.len(self.text)-1;if checkAreaPress(self.pos.x,self.pos.y,Q,self.pos.y,H,I)then self.callbacks.onPress(self,k)return true else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function Header:hide(s)assert(type(s)=='boolean','Header.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Header.__index=Header;Label={}function Label.new(H,I,J,a1,a2)assert(type(H)=='number','Label.new: x must be a number, got '..type(H))assert(type(I)=='number','Label.new: y must be a number, got '..type(I))J=tostring(J)a1=tonumber(a1)a2=tonumber(a2)if not a1 then a1=globalTextColor end;_newLabel={text=J,hidden=false,pos={x=H,y=I},colors={textColor=a1,backgroundTextColor=a2},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newLabel,Label)return _newLabel end;function Label:draw()if not self.hidden then self.callbacks.onDraw(self)local C=globalTextColor;local D=globalBackgroundTextColor;local a3=globalMonitor.getBackgroundColor()setTextColor(self.colors.textColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(a3)end;text(self.pos.x,self.pos.y,self.text)setTextColor(C)setBackgroundTextColor(D)end end;function Label:setCallback(k,l)assert(type(l)=='function','Label.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l end end;function Label:touch(H,I,k,_)assert(type(H)=='number','Label.touch: x must be a number, got '..type(H))assert(type(I)=='number','Label.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then local Q=self.pos.x+string.len(self.text)-1;if checkAreaPress(self.pos.x,self.pos.y,Q,self.pos.y,H,I)then self.callbacks.onPress(self,k)return true else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function Label:hide(s)assert(type(s)=='boolean','Label.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Label.__index=Label;Button={}function Button.new(O,P,Q,R,J,a1,a2,a6,a7)assert(type(O)=='number','Button.new: x1 must be a number, got '..type(O))assert(type(P)=='number','Button.new: y1 must be a number, got '..type(P))assert(type(Q)=='number','Button.new: x2 must be a number, got '..type(Q))assert(type(R)=='number','Button.new: y2 must be a number, got '..type(R))J=tostring(J)a1=tonumber(a1)a2=tonumber(a2)a6=tonumber(a6)a7=tonumber(a7)if not a1 then a1=globalTextColor end;if not a6 then a6=globalColor end;if not a7 then a7=globalColor end;_newButton={text=J,state=false,hidden=false,pos={x1=O,y1=P,x2=Q,y2=R},colors={textColor=a1,backgroundTextColor=a2,pressedButtonColor=a6,notPressedButtonColor=a7},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(_newButton,Button)return _newButton end;function Button:draw()if not self.hidden then self.callbacks.onDraw(self)local a0=globalRectangleType;local E=globalColor;local C=globalTextColor;local D=globalBackgroundTextColor;setRectangleType(rectangleTypes.filled)if self.state then setColor(self.colors.pressedButtonColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(self.colors.pressedButtonColor)end else setColor(self.colors.notPressedButtonColor)if self.colors.backgroundTextColor then setBackgroundTextColor(self.colors.backgroundTextColor)else setBackgroundTextColor(self.colors.notPressedButtonColor)end end;setTextColor(self.colors.textColor)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)local a8=self.pos.x1+math.floor((self.pos.x2-self.pos.x1-string.len(self.text)+1)/2)local a9=self.pos.y1+math.floor((self.pos.y2-self.pos.y1)/2)text(a8,a9,self.text)setRectangleType(a0)setColor(E)setTextColor(C)setBackgroundTextColor(D)end end;function Button:setCallback(k,l)assert(type(l)=='function','Button.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l end end;function Button:touch(H,I,k,_)assert(type(H)=='number','Button.touch: x must be a number, got '..type(H))assert(type(I)=='number','Button.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,H,I)then self.state=not self.state;self.callbacks.onPress(self,k)return true else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function Button:hide(s)assert(type(s)=='boolean','Button.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Button.__index=Button;Menu={}function Menu.new(O,P,Q,R,F)assert(type(O)=='number','Menu.new: x1 must be a number, got '..type(O))assert(type(P)=='number','Menu.new: y1 must be a number, got '..type(P))assert(type(Q)=='number','Menu.new: x2 must be a number, got '..type(Q))assert(type(R)=='number','Menu.new: y2 must be a number, got '..type(R))F=tonumber(F)if not F then F=globalColor end;_newMenu={color=F,objs={},hidden=true,pos={x1=O,y1=P,x2=Q,y2=R},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onButtonPress=function()end,onFailedButtonPress=function()end}}setmetatable(_newMenu,Menu)return _newMenu end;function Menu:draw()if not self.hidden then self.callbacks.onDraw(self)local a0=globalRectangleType;local E=globalColor;setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)for aa=#self.objs,1,-1 do local ab=self.objs[aa]ab:draw()end;setColor(E)end end;function Menu:setCallback(k,l)assert(type(l)=='function','Menu.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l elseif k==4 then self.callbacks.onButtonPress=l elseif k==5 then self.callbacks.onFailedButtonPress=l end end;function Menu:set(e,ac)for g,ab in pairs(e)do assert(getmetatable(ab)==Button,'Menu.set: you can only attach buttons to menus.')end;local ad=math.abs(self.pos.x2-self.pos.x1)+1;local ae=math.abs(self.pos.y2-self.pos.y1)+1;for aa=ae+1,#e do table.remove(e,ae+1)end;local af=math.floor(ae/#e)local ag,ah,ai,aj;if self.pos.x1>self.pos.x2 then ag=self.pos.x2;ah=self.pos.x1 else ag=self.pos.x1;ah=self.pos.x2 end;if self.pos.y1>self.pos.y2 then ai=self.pos.y2;aj=self.pos.y1 else ai=self.pos.y1;aj=self.pos.y2 end;for g,ab in pairs(e)do ab.pos.x1=ag;ab.pos.x2=ah;if ac then ab.pos.y1=ai+(g-1)*af;ab.pos.y2=ai+(g-1)*af+af-1 else ab.pos.y1=ai+g-1;ab.pos.y2=ai+g-1 end;ab.text=string.sub(ab.text,0,ad)table.insert(self.objs,ab)end end;function Menu:touch(H,I,k,_)assert(type(H)=='number','Menu.touch: x must be a number, got '..type(H))assert(type(I)=='number','Menu.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,H,I)then self.callbacks.onPress(self,k)local ak=false;for g,ab in pairs(self.objs)do if ab:touch(H,I,k,ak)then self.callbacks.onButtonPress(self,ab,k)ak=true else self.callbacks.onFailedButtonPress(self,ab,k)end end;return ak else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function Menu:hide(s)assert(type(s)=='boolean','Menu.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Menu.__index=Menu;PercentageBar={}function PercentageBar.new(O,P,Q,R,i,al,am,an,ao,ap,aq,ar)assert(type(O)=='number','PercentageBar.new: x1 must be a number, got '..type(O))assert(type(P)=='number','PercentageBar.new: y1 must be a number, got '..type(P))assert(type(Q)=='number','PercentageBar.new: x2 must be a number, got '..type(Q))assert(type(R)=='number','PercentageBar.new: y2 must be a number, got '..type(R))assert(type(i)=='number','PercentageBar.new: value must be a number, got '..type(i))assert(type(al)=='number','PercentageBar.new: min must be a number, got '..type(al))assert(type(am)=='number','PercentageBar.new: max must be a number, got '..type(am))ao=tonumber(ao)ap=tonumber(ap)aq=tonumber(aq)ar=tonumber(ar)if not ao then ao=globalTextColor end;if not aq then aq=globalColor end;_newPercentageBar={hidden=false,value={draw=an,drawOnPB=true,percentage=nil,current=nil,max=am,min=al},pos={x1=O,y1=P,x2=Q,y2=R},colors={valueColor=ao,backgroundValueColor=ap,barColor=aq,backgroundBarColor=ar},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}PercentageBar.setValue(_newPercentageBar,i)setmetatable(_newPercentageBar,PercentageBar)return _newPercentageBar end;function PercentageBar:draw()if not self.hidden then self.callbacks.onDraw(self)local a0=globalRectangleType;local E=globalColor;local C=globalTextColor;local D=globalBackgroundTextColor;local a3=globalMonitor.getBackgroundColor()setRectangleType(rectangleTypes.filled)local as=self.pos.x1+(self.pos.x2-self.pos.x1)*self.value.percentage/100;if self.colors.backgroundBarColor then setColor(self.colors.backgroundBarColor)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)if self.value.percentage>0 then setColor(self.colors.barColor)rectangle(self.pos.x1,self.pos.y1,as,self.pos.y2)end else if self.value.percentage>0 then setColor(self.colors.barColor)rectangle(self.pos.x1,self.pos.y1,as,self.pos.y2)end end;if self.value.draw then local at=self.value.percentage..'%'local au=self.pos.x1+math.floor((self.pos.x2-self.pos.x1-string.len(at)+1)/2)local av;if self.value.drawOnPB then av=self.pos.y1+math.floor((self.pos.y2-self.pos.y1)/2)else if self.pos.y1>self.pos.y2 then av=self.pos.y1+1 else av=self.pos.y2+1 end end;setTextColor(self.colors.valueColor)if self.colors.backgroundValueColor then setBackgroundTextColor(self.colors.backgroundValueColor)text(au,av,at)else if self.value.drawOnPB then if self.colors.backgroundBarColor then setBackgroundTextColor(self.colors.backgroundBarColor)else setBackgroundTextColor(a3)end;if self.pos.x1<self.pos.x2 then local aw=math.floor(as)-au+1;if aw<0 then aw=0 elseif aw>string.len(at)then aw=string.len(at)end;if aw<string.len(at)then text(au,av,at)end;if aw>0 then setBackgroundTextColor(self.colors.barColor)text(au,av,string.sub(at,1,aw))end else local aw=au+string.len(at)-math.ceil(as)if aw<0 then aw=0 elseif aw>string.len(at)then aw=string.len(at)end;if aw<string.len(at)then text(au,av,at)end;if aw>0 then setBackgroundTextColor(self.colors.barColor)text(au+string.len(at)-aw,av,string.sub(at,-aw))end end else setBackgroundTextColor(a3)text(au,av,self.value.percentage..'%')end end end;setRectangleType(a0)setColor(E)setTextColor(C)setBackgroundTextColor(D)end end;function PercentageBar:setCallback(k,l)assert(type(l)=='function','PercentageBar.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l end end;function PercentageBar:setValue(i)assert(type(i)=='number','PercentageBar.setValue: value must be a number, got '..type(i))if i<self.value.min then i=self.value.min end;if i>self.value.max then i=self.value.max end;self.value.current=i;self.value.percentage=math.floor((self.value.current-self.value.min)/(self.value.max-self.value.min)*100)end;function PercentageBar:touch(H,I,k,_)assert(type(H)=='number','PercentageBar.touch: x must be a number, got '..type(H))assert(type(I)=='number','PercentageBar.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,H,I)then self.callbacks.onPress(self,k)return true else self.callbacks.onFailedPress(self,k)return false end else self.callbacks.onFailedPress(self,k)end end;return false end;function PercentageBar:hide(s)assert(type(s)=='boolean','PercentageBar.hide: bool must be a boolean, got '..type(s))self.hidden=s end;PercentageBar.__index=PercentageBar;Memo={}function Memo.new(O,P,Q,R,a1,a2,F,ax)assert(type(O)=='number','Memo.new: x1 must be a number, got '..type(O))assert(type(P)=='number','Memo.new: y1 must be a number, got '..type(P))assert(type(Q)=='number','Memo.new: x2 must be a number, got '..type(Q))assert(type(R)=='number','Memo.new: y2 must be a number, got '..type(R))a1=tonumber(a1)a2=tonumber(a2)F=tonumber(F)ax=tonumber(ax)if not a1 then a1=globalTextColor end;if not F then F=globalColor end;if not a2 then a2=F end;if not ax then ax=colors.white end;_newMemo={active=false,hidden=false,selfLoop=false,lines={},pos={x1=O,y1=P,x2=Q,y2=R},editSettings={editable=true,charEvent=true,keyEvent=true},cursor={text=' ',colors={textColor=a1,backgroundTextColor=ax},visible=false,blink={automatic=true,enabled=false,clock=os.clock(),speed=0.5},pos={char=1,line=1},limits={enabled=true,char=math.abs(Q-O)+1,line=math.abs(R-P)+1}},colors={textColor=a1,backgroundTextColor=a2,color=F},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onEdit=function()end,onCursorBlink=function()end,onActivated=function()end,onDeactivated=function()end}}setmetatable(_newMemo,Memo)return _newMemo end;function Memo:draw()if not self.hidden then self.callbacks.onDraw(self)local a0=globalRectangleType;local E=globalColor;local C=globalTextColor;local D=globalBackgroundTextColor;local a3=globalMonitor.getBackgroundColor()local ay,az,aA,aB;if self.pos.x1>self.pos.x2 then ay=self.pos.x2;az=self.pos.x1 else ay=self.pos.x1;az=self.pos.x2 end;if self.pos.y1>self.pos.y2 then aA=self.pos.y2;aB=self.pos.y1 else aA=self.pos.y1;aB=self.pos.y2 end;setRectangleType(rectangleTypes.filled)setColor(self.colors.color)setTextColor(self.colors.textColor)setBackgroundTextColor(self.colors.backgroundTextColor)rectangle(ay,aA,az,aB)local aC=az-ay;local aD=aB-aA;local aE={x=self.cursor.pos.char-1,y=self.cursor.pos.line-1}if aE.x>aC then aE.x=aC elseif aE.x<0 then aE.x=0 end;if aE.y>aD then aE.y=aD elseif aE.y<0 then aE.y=0 end;for aa=0,math.abs(aB-aA)do if self.cursor.pos.line-1<=aD then if self.lines[aa+1]then if self.cursor.pos.char-1<=aC then text(ay,aA+aa,string.sub(self.lines[aa+1],1,aC+1))else text(ay,aA+aa,string.sub(self.lines[aa+1],self.cursor.pos.char-aC,self.cursor.pos.char))end end else if self.lines[aa+self.cursor.pos.line-aD]then if self.cursor.pos.char-1<=aC then text(ay,aA+aa,string.sub(self.lines[aa+self.cursor.pos.line-aD],1,aC+1))else text(ay,aA+aa,string.sub(self.lines[aa+self.cursor.pos.line-aD],self.cursor.pos.char-aC,self.cursor.pos.char))end end end end;if self.cursor.visible then setTextColor(self.cursor.colors.textColor)setBackgroundTextColor(self.cursor.colors.backgroundTextColor)text(ay+aE.x,aA+aE.y,self.cursor.text)end;setRectangleType(a0)setColor(E)setTextColor(C)setBackgroundTextColor(D)end end;function Memo:setCallback(k,l)assert(type(l)=='function','Memo.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l elseif k==4 then self.callbacks.onEdit=l elseif k==5 then self.callbacks.onCursorBlink=l elseif k==6 then self.callbacks.onActivated=l elseif k==7 then self.callbacks.onDeactivated=l end end;function Memo:setCursorLimits(aF,aG)assert(type(aF)=='number'or type(aF)=='nil','Memo.setCursorLimits: char must be a number or nil, got '..type(aF))assert(type(aG)=='number'or type(aG)=='nil','Memo.setCursorLimits: line must be a number or nil, got '..type(aG))self.cursor.limits.char=aF;self.cursor.limits.line=aG end;function Memo:setCursorPos(aF,aG,aH)assert(type(aF)=='number','Memo.setCursorPos: char must be a number, got '..type(aF))assert(type(aG)=='number','Memo.setCursorPos: line must be a number, got '..type(aG))if aF<1 then aF=1 end;if aG<1 then aG=1 end;if self.cursor.limits.enabled then if self.cursor.limits.char then if aF>self.cursor.limits.char+1 then aF=self.cursor.limits.char end end;if self.cursor.limits.line then if aG>self.cursor.limits.line then aG=self.cursor.limits.line end end end;if not self.lines[aG]then if aH then for aa=#self.lines+1,aG do table.insert(self.lines,'')end else if#self.lines>0 then aG=#self.lines else aG=1 end end end;if self.lines[aG]then if aF>#self.lines[aG]+1 then aF=#self.lines[aG]+1 end else aF=1 end;self.cursor.pos.char=aF;self.cursor.pos.line=aG end;function Memo:edit(k)if not self.editSettings.editable then return end;if not self.hidden then local function aI(event)if not event then return false end;if not self.lines[1]then self:setCursorPos(1,1,true)end;self.callbacks.onEdit(self,event)if self.cursor.limits.enabled then if self.cursor.limits.line then if#self.lines>self.cursor.limits.line then for aa=self.cursor.limits.line+1,#self.lines+1 do table.remove(self.lines,self.cursor.limits.line)end end end;for g,h in pairs(self.lines)do if self.cursor.limits.char then if#h>self.cursor.limits.char then self.lines[g]=h:sub(1,self.cursor.limits.char)end end end end;if event[1]=='monitor_touch'and(event[2]==globalMonitorName or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,event[2]))then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,event[3],event[4])then return true else return false end elseif event[1]=='mouse_click'and(globalMonitorName=='term'or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,'term'))then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,event[3],event[4])then return true else return false end elseif event[1]=='char'and self.editSettings.charEvent then local aJ=self.lines[self.cursor.pos.line]if self.cursor.limits.enabled then if self.cursor.limits.char then if self.cursor.pos.char<=self.cursor.limits.char then self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)..event[2]..aJ:sub(self.cursor.pos.char,#aJ)self.cursor.pos.char=self.cursor.pos.char+1 end else self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)..event[2]..aJ:sub(self.cursor.pos.char,#aJ)self.cursor.pos.char=self.cursor.pos.char+1 end else self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)..event[2]..aJ:sub(self.cursor.pos.char,#aJ)self.cursor.pos.char=self.cursor.pos.char+1 end elseif event[1]=='key'and self.editSettings.keyEvent then local aJ=self.lines[self.cursor.pos.line]if event[2]==28 then if self.cursor.limits.enabled then if self.cursor.limits.line then if#self.lines+1<=self.cursor.limits.line then table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aJ:sub(self.cursor.pos.char,#aJ)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aJ:sub(self.cursor.pos.char,#aJ)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else table.insert(self.lines,self.cursor.pos.line+1,'')self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)self.lines[self.cursor.pos.line+1]=aJ:sub(self.cursor.pos.char,#aJ)..self.lines[self.cursor.pos.line+1]self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end elseif event[2]==14 then if self.cursor.pos.char>1 then self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-2)..aJ:sub(self.cursor.pos.char,#aJ)self.cursor.pos.char=self.cursor.pos.char-1 elseif self.cursor.pos.line>1 then local aK=#self.lines[self.cursor.pos.line-1]if self.cursor.limits.enabled then if self.cursor.limits.char then if aK+#aJ<=self.cursor.limits.char then self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aJ:sub(self.cursor.pos.char,#aJ)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aK+1 end else self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aJ:sub(self.cursor.pos.char,#aJ)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aK+1 end else self.lines[self.cursor.pos.line-1]=self.lines[self.cursor.pos.line-1]..aJ:sub(self.cursor.pos.char,#aJ)table.remove(self.lines,self.cursor.pos.line)self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=aK+1 end end elseif event[2]==211 then if self.cursor.pos.char>#aJ then if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.char then if#self.lines[self.cursor.pos.line+1]+#aJ<=self.cursor.limits.char then self.lines[self.cursor.pos.line]=aJ..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end else self.lines[self.cursor.pos.line]=aJ..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end else self.lines[self.cursor.pos.line]=aJ..self.lines[self.cursor.pos.line+1]table.remove(self.lines,self.cursor.pos.line+1)end end else self.lines[self.cursor.pos.line]=aJ:sub(0,self.cursor.pos.char-1)..aJ:sub(self.cursor.pos.char+1,#aJ)end elseif event[2]==203 then if self.cursor.pos.char>1 then self.cursor.pos.char=self.cursor.pos.char-1 else if self.cursor.pos.line>1 then self.cursor.pos.line=self.cursor.pos.line-1;self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end elseif event[2]==205 then if self.cursor.pos.char<=#aJ then if self.cursor.limits.enabled then if self.cursor.limits.char then if self.cursor.pos.char<=self.cursor.limits.char then self.cursor.pos.char=self.cursor.pos.char+1 end else self.cursor.pos.char=self.cursor.pos.char+1 end else self.cursor.pos.char=self.cursor.pos.char+1 end else if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.line then if self.cursor.pos.line<self.cursor.limits.line then self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end else self.cursor.pos.line=self.cursor.pos.line+1;self.cursor.pos.char=1 end end end elseif event[2]==200 then if self.cursor.pos.line>1 then self.cursor.pos.line=self.cursor.pos.line-1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end elseif event[2]==208 then if self.lines[self.cursor.pos.line+1]then if self.cursor.limits.enabled then if self.cursor.limits.line then if self.cursor.pos.line<self.cursor.limits.line then self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end else self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end else self.cursor.pos.line=self.cursor.pos.line+1;if self.cursor.pos.char-1>#self.lines[self.cursor.pos.line]then self.cursor.pos.char=#self.lines[self.cursor.pos.line]+1 end end end end end;return true end;if not self.selfLoop then aI(k)else self.active=true;while self.active do local aL=os.startTimer(self.cursor.blink.speed/2)k={os.pullEvent()}if not aI(k)then break end;self:draw()if self.cursor.blink.enabled then if os.clock()>=self.cursor.blink.clock+self.cursor.blink.speed then self.cursor.blink.clock=os.clock()self.callbacks.onCursorBlink(self,k)self.cursor.visible=not self.cursor.visible end end;os.cancelTimer(aL)end end end end;function Memo:touch(H,I,k,_)assert(type(H)=='number','Memo.touch: x must be a number, got '..type(H))assert(type(I)=='number','Memo.touch: y must be a number, got '..type(I))if not self.hidden then if not _ and checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,H,I)then self.callbacks.onPress(self,k)self.active=true;self.callbacks.onActivated(self,k)if self.selfLoop then self.cursor.blink.enabled=true;self.cursor.visible=true;self:edit(k)self.active=false;self.callbacks.onDeactivated(self,k)self.cursor.blink.enabled=false;self.cursor.visible=false elseif self.editSettings.editable and self.cursor.blink.automatic then self.cursor.blink.enabled=true;self.cursor.visible=true end;return true else self.callbacks.onFailedPress(self,k)if self.active then self.active=false;self.callbacks.onDeactivated(self,k)if self.editSettings.editable and self.cursor.blink.automatic then self.cursor.blink.enabled=false;self.cursor.visible=false end end;return false end end;if self.active then self.active=false;self.callbacks.onDeactivated(self,k)end;return false end;function Memo:tick(k)if not self.hidden then if not self.selfLoop then if self.cursor.blink.enabled then if os.clock()>=self.cursor.blink.clock+self.cursor.blink.speed then self.cursor.blink.clock=os.clock()self.callbacks.onCursorBlink(self,k)self.cursor.visible=not self.cursor.visible end end end end end;function Memo:key(k)if not self.hidden then if not self.selfLoop then if self.active then self:edit(k)end end end end;function Memo:char(k)if not self.hidden then if not self.selfLoop then if self.active then self:edit(k)end end end end;function Memo:write(a)if not a then a=''end;a=tostring(a)if not self.lines[1]then self:setCursorPos(1,1,true)end;self.callbacks.onEdit(self,{'write',a})local N=stringSplit(a,'\n')for g,h in pairs(N)do if g~=1 then if self.lines[self.cursor.pos.line+1]then self:setCursorPos(#self.lines[self.cursor.pos.line+1],self.cursor.pos.line+1)else self:setCursorPos(1,self.cursor.pos.line+1,true)end end;local aJ=self.lines[self.cursor.pos.line]aJ=aJ:sub(0,self.cursor.pos.char-1)..h..aJ:sub(self.cursor.pos.char,#aJ)self.lines[self.cursor.pos.line]=aJ;self:setCursorPos(self.cursor.pos.char+#h,self.cursor.pos.line)if self.cursor.limits.enabled then if self.cursor.limits.char then if#aJ>self.cursor.limits.char then aJ=aJ:sub(1,self.cursor.limits.char)end end end;self.lines[self.cursor.pos.line]=aJ end end;function Memo:print(a)if not a then a=''end;a=tostring(a)self:write(a..'\n')end;function Memo:clear()self.cursor.pos.char=1;self.cursor.pos.line=1;self.lines={}end;function Memo:enableSelfLoop(s)assert(type(s)=='boolean','Memo.enableSelfLoop: bool must be a boolean, got '..type(s))self.selfLoop=s end;function Memo:limits(s)assert(type(s)=='boolean','Memo.limits: bool must be a boolean, got '..type(s))self.cursor.limits.enabled=s end;function Memo:editable(s)assert(type(s)=='boolean','Memo.editable: bool must be a boolean, got '..type(s))self.editSettings.editable=s end;function Memo:hide(s)assert(type(s)=='boolean','Memo.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Memo.__index=Memo;Window={}function Window.new(O,P,Q,R,F)assert(type(O)=='number','Window.new: x1 must be a number, got '..type(O))assert(type(P)=='number','Window.new: y1 must be a number, got '..type(P))assert(type(Q)=='number','Window.new: x2 must be a number, got '..type(Q))assert(type(R)=='number','Window.new: y2 must be a number, got '..type(R))F=tonumber(F)if not F then F=term.getBackgroundColor()end;_newWindow={active=false,hidden=false,color=F,grabbedFrom={x=1,y=1},shadow={enabled=false,color=colors.black,offset={x=1,y=1}},objs={list={},events={draw={},touch={},tick={},key={},char={},mouse_drag={}}},pos={x1=O,y1=P,x2=Q,y2=R},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onOBJPress=function()end,onFailedOBJPress=function()end,onEvent=function()end}}setmetatable(_newWindow,Window)return _newWindow end;function Window:draw()if not self.hidden then self.callbacks.onDraw(self)local a0=globalRectangleType;local E=globalColor;setRectangleType(rectangleTypes.filled)if self.shadow.enabled then setColor(self.shadow.color)local aM=self.shadow.offset.x;local aN=self.shadow.offset.y;local aO=self.pos.x1+aM;local aP=self.pos.x2+aM;local aQ=self.pos.y1+aN;local aR=self.pos.y2+aN;rectangle(aO,aQ,aP,aR)end;setColor(self.color)rectangle(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2)setRectangleType(a0)setColor(E)for o,ab in pairs(self.objs.events.draw)do ab:draw()end end end;function Window:setCallback(k,l)assert(type(l)=='function','Window.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onPress=l elseif k==3 then self.callbacks.onFailedPress=l elseif k==4 then self.callbacks.onOBJPress=l elseif k==5 then self.callbacks.onFailedOBJPress=l elseif k==6 then self.callbacks.onEvent=l end end;function Window:set(aS)assert(type(aS)=='table','Window.set: objGroup must be a table, got '..type(aS))self.objs.list=aS;self.objs.events=getOBJSEvents(aS)end;function Window:touch(H,I,k,_)assert(type(H)=='number','Window.touch: x must be a number, got '..type(H))assert(type(I)=='number','Window.touch: y must be a number, got '..type(I))if not self.hidden then self.callbacks.onEvent(self,k)if not _ then if checkAreaPress(self.pos.x1,self.pos.y1,self.pos.x2,self.pos.y2,H,I)then self.active=true;self.grabbedFrom.x=H;self.grabbedFrom.y=I;self.callbacks.onPress(self,k)local ak=false;for o,ab in pairs(self.objs.events.touch)do if ab:touch(H,I,k,ak)then self.callbacks.onOBJPress(self,ab,k)ak=true else self.callbacks.onFailedOBJPress(self,ab,k)end end;return true else self.active=false;self.callbacks.onFailedPress(self,k)return false end else self.active=false;self.callbacks.onFailedPress(self,k)end end;return false end;function Window:mouse_drag(k)if not self.hidden then self.callbacks.onEvent(self,k)if self.active then local aT=k[3]-self.grabbedFrom.x;local aU=k[4]-self.grabbedFrom.y;self.grabbedFrom.x=k[3]self.grabbedFrom.y=k[4]self.pos.x1=self.pos.x1+aT;self.pos.x2=self.pos.x2+aT;self.pos.y1=self.pos.y1+aU;self.pos.y2=self.pos.y2+aU;for o,ab in pairs(self.objs.list)do if ab.pos.x then ab.pos.x=ab.pos.x+aT end;if ab.pos.x1 then ab.pos.x1=ab.pos.x1+aT end;if ab.pos.x2 then ab.pos.x2=ab.pos.x2+aT end;if ab.pos.y then ab.pos.y=ab.pos.y+aU end;if ab.pos.y1 then ab.pos.y1=ab.pos.y1+aU end;if ab.pos.y2 then ab.pos.y2=ab.pos.y2+aU end end end end end;function Window:tick(k)if not self.hidden then self.callbacks.onEvent(self,k)for g,ab in pairs(self.objs.events.tick)do ab:tick(k)end end end;function Window:key(k)if not self.hidden then self.callbacks.onEvent(self,k)for g,ab in pairs(self.objs.events.key)do ab:key(k)end end end;function Window:char(k)if not self.hidden then self.callbacks.onEvent(self,k)for g,ab in pairs(self.objs.events.char)do ab:char(k)end end end;function Window:hide(s)assert(type(s)=='boolean','Window.hide: bool must be a boolean, got '..type(s))self.hidden=s end;Window.__index=Window;OBJGroup={}function OBJGroup.new()_newOBJGroup={objs={list={},events={draw={},touch={},tick={},key={},char={},mouse_drag={}}},hidden=false,callbacks={onDraw=function()end,onOBJPress=function()end,onFailedOBJPress=function()end}}setmetatable(_newOBJGroup,OBJGroup)return _newOBJGroup end;function OBJGroup:draw()if not self.hidden then self.callbacks.onDraw(self)for o,ab in pairs(self.objs.events.draw)do ab:draw()end end end;function OBJGroup:setCallback(k,l)assert(type(l)=='function','OBJGroup.setCallback: callback must be a function, got '..type(l))if k==1 then self.callbacks.onDraw=l elseif k==2 then self.callbacks.onOBJPress=l elseif k==3 then self.callbacks.onFailedOBJPress=l end end;function OBJGroup:set(aS)assert(type(aS)=='table','OBJGroup.set: objGroup must be a table, got '..type(aS))self.objs.list=aS;self.objs.events=getOBJSEvents(aS)end;function OBJGroup:touch(H,I,k,_)assert(type(H)=='number','OBJGroup.touch: x must be a number, got '..type(H))assert(type(I)=='number','OBJGroup.touch: y must be a number, got '..type(I))if not self.hidden then if not _ then local ak=false;for o,ab in pairs(self.objs.list)do if ab:touch(H,I,k,ak)then self.callbacks.onOBJPress(self,ab,k)ak=true else self.callbacks.onFailedOBJPress(self,ab,k)end end;return ak end end;return false end;function OBJGroup:tick(k)if not self.hidden then for g,ab in pairs(self.objs.events.tick)do ab:tick(k)end end end;function OBJGroup:key(k)if not self.hidden then for g,ab in pairs(self.objs.events.key)do ab:key(k)end end end;function OBJGroup:char(k)if not self.hidden then for g,ab in pairs(self.objs.events.char)do ab:char(k)end end end;function OBJGroup:mouse_drag(k)if not self.hidden then for g,ab in pairs(self.objs.events.mouse_drag)do ab:mouse_drag(k)end end end;function OBJGroup:hide(s)assert(type(s)=='boolean','OBJGroup.hide: bool must be a boolean, got '..type(s))self.hidden=s end;OBJGroup.__index=OBJGroup;globalLoop.stats.FPS=Label.new(0,0,'0FPS')globalLoop.stats.EPS=Label.new(0,0,'0EPS')globalLoop.stats.FPS.hidden=true;globalLoop.stats.EPS.hidden=true;table.insert(globalLoop.group.LIBPrivate.objs,globalLoop.stats.FPS)table.insert(globalLoop.group.LIBPrivate.objs,globalLoop.stats.EPS)function drawOnLoopClock()globalLoop.drawOnClock=true end;function drawOnLoopEvent()globalLoop.drawOnClock=false end;function drawLoopStats(s)assert(type(s)=='boolean','enableLoopStats: bool must be a boolean, got '..type(s))if s and globalLoop.stats.automaticPos then local aV=globalLoop.stats.automaticPosOffset.x;local aW=globalLoop.stats.automaticPosOffset.y;globalLoop.stats.FPS.pos.x=globalMonitorWidth-#globalLoop.stats.FPS.text+1+aV;globalLoop.stats.FPS.pos.y=globalMonitorHeight-1+aW;globalLoop.stats.EPS.pos.x=globalMonitorWidth-#globalLoop.stats.EPS.text+1+aV;globalLoop.stats.EPS.pos.y=globalMonitorHeight+aW end;globalLoop.stats.FPS.hidden=not s;globalLoop.stats.EPS.hidden=not s end;function setLoopClockSpeed(aX)assert(type(aX)=='number','setLoopClockSpeed: sec must be a number, got '..type(aX))globalLoop.clockSpeed=aX end;function setLoopTimerSpeed(aX)assert(type(aX)=='number','setLoopTimerSpeed: sec must be a number, got '..type(aX))globalLoop.timerSpeed=aX end;function setLoopCallback(k,l)assert(type(l)=='function','setLoopCallback: callback must be a function, got '..type(l))if k==1 then globalLoop.callbacks.onInit=l elseif k==2 then globalLoop.callbacks.onClock=l elseif k==3 then globalLoop.callbacks.onEvent=l elseif k==4 then globalLoop.callbacks.onTimer=l elseif k==5 then globalLoop.callbacks.onMonitorChange=l end end;function loopAutoClear(s)assert(type(s)=='boolean','loopAutoClear: bool must be a boolean, got '..type(s))globalLoop.autoClear=s end;function addLoopGroup(aY,aZ)aY=tostring(aY)assert(aY~='LIBPrivate'or aY~='none',"addLoopGroup: can't overwrite Lib's Private groups")assert(type(aZ)=='table','addLoopGroup: group must be a table, got '..type(aZ))globalLoop.group[aY]={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs=aZ}end;function removeLoopGroup(aY)aY=tostring(aY)assert(aY~='LIBPrivate'or aY~='none',"removeLoopGroup: can't remove Lib's Private groups")globalLoop.group[aY]=nil end;function setLoopGroup(aY)aY=tostring(aY)assert(globalLoop.group[aY],'setLoopGroup: groupName must be a valid group.')local a_=globalLoop.group[globalLoop.selectedGroup]local b0=globalLoop.group[aY]a_.callbacks.onUnset(a_,b0)globalLoop.selectedGroup=aY;b0.callbacks.onSet(b0,a_)globalLoop.wasGroupChanged=true end;function setLoopGroupCallback(aY,k,l)aY=tostring(aY)assert(aY~='LIBPrivate'or aY~='none',"setLoopGroupCallback: can't overwrite Lib's Private groups' callbacks")assert(globalLoop.group[aY],'setLoopGroupCallback: groupName must be a valid group.')assert(type(l)=='function','setLoopGroupCallback: callback must be a function, got '..type(l))if k==1 then globalLoop.group[aY].callbacks.onClock=l elseif k==2 then globalLoop.group[aY].callbacks.onEvent=l elseif k==3 then globalLoop.group[aY].callbacks.onTimer=l elseif k==4 then globalLoop.group[aY].callbacks.onMonitorChange=l elseif k==5 then globalLoop.group[aY].callbacks.onSet=l elseif k==6 then globalLoop.group[aY].callbacks.onUnset=l end end;function resetLoopSettings()globalLoop.APLWDBroadcastOnClock=false;globalLoop.APLWDClearCacheOnDraw=true;globalLoop.stats.FPS.hidden=true;globalLoop.stats.EPS.hidden=true;globalLoop.callbacks.onInit=function()end;globalLoop.callbacks.onEvent=function()end;globalLoop.callbacks.onClock=function()end;globalLoop.selectedGroup='none'globalLoop.group={none={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}},LIBPrivate={callbacks={onClock=function()end,onEvent=function()end,onTimer=function()end,onMonitorChange=function()end,onSet=function()end,onUnset=function()end},objs={}}}globalLoop.events={draw={},touch={},tick={},key={},char={},mouse_drag={}}end;function stopLoop()globalLoop.enabled=false;globalLoop.events={draw={},touch={},tick={},key={},char={},mouse_drag={}}end;function loop()globalLoop.enabled=true;if globalLoop.autoClear then bClearMonitorGroup()end;updateLoopEvents()globalLoop.callbacks.onInit()drawLoopOBJs()local b1=Clock.new(1)b1.FPS=0;b1.EPS=0;b1:setCallback(event.clock.onClock,function(self,event)globalLoop.stats.FPS.text=tostring(self.FPS)..'FPS'globalLoop.stats.EPS.text=tostring(self.EPS)..'EPS'if globalLoop.stats.automaticPos then local aV=globalLoop.stats.automaticPosOffset.x;local aW=globalLoop.stats.automaticPosOffset.y;globalLoop.stats.FPS.pos.x=globalMonitorWidth-#globalLoop.stats.FPS.text+1+aV;globalLoop.stats.FPS.pos.y=globalMonitorHeight-1+aW;globalLoop.stats.EPS.pos.x=globalMonitorWidth-#globalLoop.stats.EPS.text+1+aV;globalLoop.stats.EPS.pos.y=globalMonitorHeight+aW end;self.FPS=0;self.EPS=0 end)local b2=os.clock()while globalLoop.enabled do if globalLoop.wasGroupChanged then updateLoopEvents()globalLoop.wasGroupChanged=false end;local aL=os.startTimer(globalLoop.timerSpeed)local event={os.pullEvent()}if event[1]=='monitor_touch'and(event[2]==globalMonitorName or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,event[2]))then touchLoopOBJs(event[3],event[4],event)elseif event[1]=='mouse_click'and(globalMonitorName=='term'or globalMonitorGroup.enabled and tableHasValue(globalMonitorGroup.list,'term'))then touchLoopOBJs(event[3],event[4],event)elseif event[1]=='key'then for o,ab in pairs(globalLoop.events.key)do ab:key(event)end elseif event[1]=='char'then for o,ab in pairs(globalLoop.events.char)do ab:char(event)end elseif event[1]=='mouse_drag'then for o,ab in pairs(globalLoop.events.mouse_drag)do ab:mouse_drag(event)end elseif event[1]=='timer'then globalLoop.callbacks.onTimer(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onTimer(event)end;globalLoop.clock=os.clock()if globalLoop.clock>=b2+globalLoop.clockSpeed then b2=os.clock()if globalLoop.drawOnClock then if APLWD.enabled and globalLoop.APLWDClearCacheOnDraw then APLWD.clearCache()end;if globalLoop.autoClear then bClearMonitorGroup()end;globalLoop.callbacks.onClock(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onClock(event)drawLoopOBJs()b1.FPS=b1.FPS+1 else globalLoop.callbacks.onClock(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onClock(event)end;if APLWD.enabled and globalLoop.APLWDBroadcastOnClock then APLWD.broadcastCache()end end;if not globalLoop.drawOnClock then if APLWD.enabled and globalLoop.APLWDClearCacheOnDraw then APLWD.clearCache()end;if globalLoop.autoClear then bClearMonitorGroup()end;globalLoop.callbacks.onEvent(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onEvent(event)drawLoopOBJs()b1.FPS=b1.FPS+1 else globalLoop.callbacks.onEvent(event)globalLoop.group[globalLoop.selectedGroup].callbacks.onEvent(event)end;for o,ab in pairs(globalLoop.events.tick)do ab:tick(event)end;b1:tick()b1.EPS=b1.EPS+1;os.cancelTimer(aL)end end;function getOBJSEvents(e)assert(type(e)=='table','getOBJSEvents: table must be a table, got '..type(e))local b3={draw={},touch={},tick={},key={},char={},mouse_drag={}}for o,ab in pairs(e)do if ab.draw then table.insert(b3.draw,1,ab)end;if ab.touch then table.insert(b3.touch,ab)end;if ab.tick then table.insert(b3.tick,ab)end;if ab.key then table.insert(b3.key,ab)end;if ab.char then table.insert(b3.char,ab)end;if ab.mouse_drag then table.insert(b3.mouse_drag,ab)end end;return b3 end;function updateLoopEvents()local b4={}for o,ab in pairs(globalLoop.group.LIBPrivate.objs)do table.insert(b4,ab)end;for o,ab in pairs(globalLoop.group[globalLoop.selectedGroup].objs)do table.insert(b4,ab)end;globalLoop.events=getOBJSEvents(b4)end;function drawLoopOBJs()if globalMonitorGroup.enabled then globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)for g,ab in pairs(globalLoop.events.draw)do ab:draw()end;local m=APLWD.cacheWritable;if APLWD.enabled and m then APLWD.cacheWritable=false end;local n=globalMonitorName;for o,monitorName in pairs(globalMonitorGroup.list)do if monitorName~=n then setMonitor(monitorName)globalLoop.callbacks.onMonitorChange(monitorName)globalLoop.group[globalLoop.selectedGroup].callbacks.onMonitorChange(monitorName)for g,ab in pairs(globalLoop.events.draw)do ab:draw()end end end;setMonitor(n)if APLWD.enabled and m then APLWD.cacheWritable=true end else for g,ab in pairs(globalLoop.events.draw)do ab:draw()end end end;function touchLoopOBJs(H,I,k)assert(type(H)=='number','touchLoopOBJs: x must be a number, got '..type(H))assert(type(I)=='number','touchLoopOBJs: y must be a number, got '..type(I))local b5=false;for o,ab in pairs(globalLoop.events.touch)do if ab:touch(H,I,k,b5)then b5=true end end end;local b6={...}if table.maxn(b6)>0 then b6[1]=string.lower(b6[1])if b6[1]=='ver'then print('Lib version: '..ver)elseif b6[1]=='setup'then if shell then local b7='/'..shell.getRunningProgram()OSSettings.set('APLibPath',b7)print('Setup completed!\nAPLibPath: '..tostring(settings.get('APLibPath')))sleep(2)os.reboot()else error("Setup failed, shell API not available!")end elseif b6[1]=='create'then if b6[2]then local J="\n-- //AUTO-GENERATED-CODE//\nlocal APLibPath = settings.get('APLibPath')\n\nassert(  -- check if setup was done before, if not return with an error\n    type(APLibPath) == 'string',\n"..'    "'.."Couldn't open APLib through path: "..'"..tostring(\n'.."        APLibPath\n"..'    ).."'.."; probably you haven't completed Lib setup via 'LIBFILE setup' or the setup failed"..'"\n)\n\n'.."assert( -- check if API is still there, if not return with an error\n    fs.exists(APLibPath),\n"..'    "'.."Couldn't open APLib through path: "..'"..tostring(\n'.."    	APLibPath\n    ).."..'"'.."; remember that if you move the API's folder you must set it up again via 'LIBFILE setup'"..'"\n)\n\n'.."os.loadAPI(APLibPath) -- load API with CraftOS's built-in feature\n\nlocal APLib = APLibPath:reverse():sub(1, APLibPath:reverse():find('/') - 1):reverse()\nif APLib:sub(#APLib - 3) == '.lua' then APLib = APLib:sub(1, #APLib - 4); end\nlocal APLib = _ENV[APLib]\n-- //--//\n\n"local b8='/'..b6[2]if fs.exists(b8)then print('Are you sure you want to overwrite: '..b8)print('Press ENTER to confirm or another key to cancel.')local event={os.pullEvent('key')}if event[2]==28 then local b9=fs.open(b8,'w')if b9 then b9.write(J)b9.close()print('File succesfully created!')else print("Couldn't create file.")end else print("File wasn't created!")end else local b9=fs.open(b8,'w')if b9 then b9.write(J)b9.close()print('File succesfully created!')else print("Couldn't create file.")end end else print('You must specify the name of the file you want to create.')end end end